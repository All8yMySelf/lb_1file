<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<!-- V2.37: Added Electronic FOV sensor range upgrade -->
<!-- V2.18: Refactored theme management to use themes.js, reinstated theme cycling -->
<!-- V2.17.1: Removed theme cycling logic and hid theme button -->
<!-- V2.17: Removed themes 2-6, updated version number -->
<!-- V2.9: Major refactor - Canvas Ring UI, Descriptive Names, Constants, Update Loop Split -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
  import { getDatabase, ref, push, query, orderByChild, limitToLast, get, onValue } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";

  // 1) Configure Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyA5CSbcR_DS601s5Ok_f-UOT_dobysD9eU",
    authDomain: "lb-1file.firebaseapp.com",
    databaseURL: "https://lb-1file-default-rtdb.firebaseio.com",
    projectId: "lb-1file",
    storageBucket: "lb-1file.firebasestorage.app",
    messagingSenderId: "828776232983",
    appId: "1:828776232983:web:a1e7b73bf46b1e5124c452",
    measurementId: "G-BTTQRHEFSJ"
  };
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);
  let leaderboardUnsub = null;

  // 2) submitScore writes to /scores
  window.submitScore = async function({ initials, wave, time, ranking }) {
    const date = new Date().toLocaleDateString("en-GB", {
      day: "numeric", month: "long", year: "numeric"
    });
    await push(ref(db, "scores"), { initials, wave, time, date, ranking });
  };

  // 3) getTopScores reads top 10 by ranking, sorts desc, returns array
  window.getTopScores = async function() {
    const q = query(ref(db, "scores"), orderByChild("ranking"), limitToLast(10));
    try {
      const snap = await get(q);
      const list = [];
      snap.forEach(child => {
        list.push(child.val());
      });
      list.sort((a, b) => b.ranking - a.ranking);
      return list;
    } catch (err) {
      console.error('Failed to fetch scores', err);
      showToast('Failed to fetch scores', 3000);
      return [];
    }
  };

  window.listenToLeaderboard = callback => {
    const q = query(ref(db, "scores"), orderByChild("ranking"), limitToLast(10));
    try {
      leaderboardUnsub = onValue(q, snap => {
        const list = [];
        snap.forEach(child => {
          list.push(child.val());
        });
        list.sort((a, b) => b.ranking - a.ranking);
        callback(list);
      }, err => {
        console.error('Failed to fetch scores', err);
        showToast('Failed to fetch scores', 3000);
      });
    } catch (err) {
      console.error('Failed to fetch scores', err);
      showToast('Failed to fetch scores', 3000);
    }
  };

  window.unlistenLeaderboard = () => {
    if (leaderboardUnsub) {
      leaderboardUnsub();
      leaderboardUnsub = null;
    }
  };

  // 4) renderLeaderboard populates #leaderboard element with 10 rows
  window.renderLeaderboard = (scores, highlightIndex = -1) => {
    const container = document.getElementById("leaderboard");
    container.textContent = "";
      for (let i = 0; i < 10; i++) {
        const row = scores[i]
          ? `${scores[i].initials} - Wave ${scores[i].wave} (${scores[i].time}s left) - ${scores[i].date}`
          : "---";
        const div = document.createElement("div");
        div.className = "leaderboard-row";
        const rankSpan = document.createElement("span");
        rankSpan.className = "rank";
        rankSpan.textContent = `${i + 1}.`;
        div.appendChild(rankSpan);
        div.appendChild(document.createTextNode(" " + (row === "&nbsp;" ? "\u00A0" : row)));
        if (i === highlightIndex) div.classList.add("highlight");
        container.appendChild(div);
      }
    document.getElementById("leaderboardLoading").style.display = "none";
  };

  // 5) Hook up “Leaderboard” button
 
    document.getElementById("show-leaderboard").addEventListener("click", async () => {
    window.showHighScores();
    const scores = await getTopScores();
    let idx = -1;
    if (pendingScore && pendingScore.saved) {
      idx = scores.findIndex(s => s.ranking === pendingScore.ranking);
    }
    renderLeaderboard(scores, idx);
    });
</script>

<title>Orbital Defence Elite v2.41 - Optimised</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
:root{--bg-gradient:linear-gradient(135deg,#0f2027,#203a43,#2c5364);--body-bg:#000;--text-color:#fff;--hud-color:#fff;--title-color:#fff;--final-stats-color:#cfab52;--button-bg:#2c220f;--button-text:#e6b54b;--button-border:#e6b54b;--button-hover-bg:#1c1404;--button-disabled-bg:#2f240c;--button-disabled-text:#ac4834;--upgrade-title-color:#e6b54b;--toggle-active-bg:#1c1404;--toggle-active-text:#e6b54b;--toast-bg:rgba(0,0,0,.7);--toast-text:#fff;--switch-bg:#2f240c;--switch-slider-color:#e6b54b;--switch-checked-bg:#1c1404;--switch-label-color:#e6b54b;--stats-border:rgba(230,181,75,.3);--stats-bg:rgba(0,0,0,.4);--hotkey-bg:rgba(0,0,0,.6);--hotkey-text:rgba(230,181,75,.8);--canvas-bg:rgba(0,0,0,.7);--crt-overlay-bg:linear-gradient(rgba(0,0,0,.6) 50%,transparent);--crt-overlay-blend:overlay;--crt-scanline-color:rgba(0,0,0,.1);--crt-vignette:radial-gradient(circle at center,transparent 60%,rgba(0,0,0,.6) 100%);--crt-interlace-color:rgba(0,0,0,.25);--font-family:"Press Start 2P",monospace;--button-font-size:24px;--upgrade-button-font-size:16px;--tab-font-size:14px;--ring-ui-font-size:11px}*{font-family:var(--font-family);box-sizing:border-box;padding:0}*,body{margin:0}body{overflow:hidden;background:var(--body-bg);color:var(--text-color)}#crt-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:9999;background-image:var(--crt-overlay-bg);background-size:100% 2px;background-blend-mode:var(--crt-overlay-blend)}#gameCanvas{background:var(--canvas-bg);touch-action:none}#gameCanvas,.bg{position:absolute;top:0;left:0}.bg{width:100%;height:100%;background:var(--bg-gradient);z-index:-1}/* HUD must stay above overlay (z-index > 5) */#hud{position:absolute;top:0;left:10px;right:10px;display:flex;justify-content:space-between;align-items:center;font-size:var(--hud-font-size);padding:0;z-index:10;line-height:2;min-height:0;color:var(--hud-color)}#gameOverScreen h1,#startScreen h1{font-size:2rem;text-align:center;overflow:hidden;text-overflow:ellipsis;color:var(--title-color)}#gameOverScreen h1{font-size:5rem;margin-bottom:1rem}#hud span{flex:1;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#hud #creditsDisplay{text-align:left}#hud #healthDisplay{text-align:right}#gameOverScreen,#highScoreModal,#leaderboard-screen,#sensorWarning,#startScreen,#enemyIdentificationPopup{position:absolute;top:0;left:0;right:0;bottom:0;display:flex;flex-direction:column;justify-content:center;align-items:center;background:rgba(0,0,0,.8);text-align:center;z-index:100}#gameOverScreen #finalStats{font-size:2rem;margin-bottom:1.5rem;color:var(--final-stats-color)}button{padding:10px 20px;font-size:var(--button-font-size);line-height:1;margin-top:22px;background:var(--button-bg);color:var(--button-text);border:2px solid var(--button-border);cursor:pointer;transition:all .3s ease}button:hover{background:var(--button-hover-bg);transform:translateY(-2px);box-shadow:0 4px 8px rgba(0,0,0,.2)}button:active{transform:translateY(1px)}button:disabled{background:var(--button-disabled-bg);color:var(--button-disabled-text);cursor:not-allowed;transform:none;box-shadow:none}/* Controls must stay above overlay (z-index > 5) */#controls{position:absolute;bottom:10px;right:10px;display:flex;gap:10px;z-index:10;align-items:center}#toggleInfoButton{width:30px;height:30px;padding:0;border-radius:50%;font-size:20px;line-height:20px}#toggleInfoButton.active{background-color:var(--toggle-active-bg);color:var(--toggle-active-text)}#fullscreenButton,#playPauseButton,#slowDownButton,#speedUpButton{width:30px;height:30px;padding:0;border-radius:50%;font-size:20px;line-height:20px}#speedDisplay{display:flex;align-items:center;justify-content:center;width:40px;font-size:18px}#toast{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);background:var(--toast-bg);color:var(--toast-text);padding:10px 20px;border-radius:20px;z-index:1000;opacity:0;transition:opacity .3s ease;pointer-events:none}#toast.show{opacity:1}.switch{position:relative;display:inline-block;width:50px;height:24px;margin-right:10px}.switch input{opacity:0;width:0;height:0}.slider{cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:var(--switch-bg);border-radius:24px}.slider,.slider:before{position:absolute;transition:.4s}.slider:before{content:"";height:16px;width:16px;left:4px;bottom:4px;background-color:var(--switch-slider-color);border-radius:50%}input:checked+.slider{background-color:var(--switch-checked-bg)}input:checked+.slider:before{transform:translateX(26px)}.switch-label{color:var(--switch-label-color);font-size:16px}.stats{display:flex;justify-content:center;gap:20px;margin-top:10px}.stats div{border:1px solid var(--stats-border);padding:5px 10px;background:var(--stats-bg);border-radius:5px}/* Hotkey panel must stay above overlay (z-index > 5) */#hotkeys{z-index:10;position:absolute;top:60px;right:10px;background:var(--hotkey-bg);padding:5px 10px;border-radius:5px;font-size:var(--hotkey-font-size);color:var(--hotkey-text);display:none}#hotkeys.show{display:block}#sensorToggle{display:flex;align-items:center;gap:5px;font-size:var(--hotkey-font-size);color:var(--hotkey-text);z-index:10}#sensorDisplayToggle{padding:2px 8px;cursor:pointer}#enemyHUD,#sensorDisplayToggle{font-size:var(--hotkey-font-size)}#enemyHUD{position:absolute;top:100px;right:10px;background:var(--hotkey-bg);padding:5px 10px;border-radius:5px;color:var(--hotkey-text);display:none;line-height:1.2;text-align:right;z-index:10;opacity:.9}#enemyHUD.show{display:block}#highScoreTable table{width:80%;margin:0 auto;border-collapse:collapse;font-size:2rem}#highScoreTable td,#highScoreTable th{padding:4px 8px;border-bottom:1px solid var(--button-border);text-align:left}#highScoreTable td{white-space:nowrap}#highScoreTable th{font-weight:700}#highScoreTable td:last-child{text-align:right}.blinking-cursor{font-weight:700;animation:a 1s step-end infinite}@keyframes a{50%{opacity:0}}#highScoreModal input{width:5ch;text-align:center;font-size:24px;background:transparent;color:var(--text-color);border:none;border-bottom:2px solid var(--button-border);outline:none}.crt-scanlines{position:absolute;top:0;left:0;width:100%;height:100%;background:repeating-linear-gradient(0deg,var(--crt-scanline-color),var(--crt-scanline-color) 1px,transparent 0,transparent 2px);pointer-events:none}.crt-container{transform:translateZ(0);position:relative;overflow:hidden}.crt-container:before{background:var(--crt-vignette);z-index:1}.crt-container:after,.crt-container:before{content:"";position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none}.crt-container:after{background:linear-gradient(hsla(0,6%,7%,0) 50%,var(--crt-interlace-color) 0);background-size:100% 4px;z-index:2}
</style>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&family=Share+Tech+Mono&family=Rajdhani&family=Orbitron&display=swap" rel="stylesheet">
<style>
  #highScoreList, #gameOverScoreList, #leaderboard { list-style: none; padding: 0; margin: 1rem 0; }
  #highScoreList li, #gameOverScoreList li, .leaderboard-row { margin: 0.2rem 0; }
  #gameOverScoreList li, .leaderboard-row { text-align: left; }
  .rank { display: inline-block; width: 2ch; }
  .highlight {
    background: yellow;
    color: black;
    border: 2px solid black;
    font-size: 1.2em;
    padding: 0.2rem;
  }
  #initialsInput { font-size: 2rem; text-align: center; width: 4ch; background: transparent; border: none; border-bottom: 2px solid var(--button-text); color: var(--button-text); caret-color: var(--button-text); }
  #cheekyMessage { margin: 1rem 0; color: var(--button-text); }
  #leaderboardLoading {
    display: none;
    width: 2rem;
    height: 2rem;
    margin: 1rem auto;
    border: 0.4rem solid var(--button-text);
    border-top-color: transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
<style>
  @media (max-width: 600px) {
    #hud { font-size: 18px; }
    #controls button { width: 24px; height: 24px; font-size: 16px; }
    #speedDisplay { width: 32px; font-size: 14px; }
  }
</style>

<style>
  .slow-blink { animation: slowBlink 2s steps(2,end) infinite; }
  @keyframes slowBlink { 50% { opacity: 0; } }
  .sub-message { margin-bottom: 1rem; color: var(--button-text); }
  .overlay-desaturate { position: absolute; inset: 0; background: rgba(0,0,0,0.5); backdrop-filter: grayscale(1); pointer-events: none; z-index: 99; }
  #enemyStatsPanel { position: absolute; right: 10px; background: var(--hotkey-bg); padding: 5px 10px; border-radius: 5px; font-size: var(--hotkey-font-size); color: var(--hotkey-text); z-index: 10; word-wrap: break-word; }
  #enemyStatsPanel.collapsed #enemyStatsContent { display: none; }
  #enemyStatsHeader { cursor: pointer; }
  #enemyStatsHeader .arrow { margin-left: 4px; }
  #overlayContainer,

  #cssOverlay {
      position: absolute;
      inset: 0;
      pointer-events: none; z-index:5;
    }
  #cssOverlay { background: rgba(0,0,0,0.6); display:none; }
  #overlayButton { margin-left:4px; }
</style>
</head>
<body>
<div class="bg"></div>
<canvas id="gameCanvas"></canvas> <!-- Renamed from #g -->
<div id="hud"> <!-- Renamed from #u -->
    <span id="creditsDisplay"></span> <!-- Renamed from #c -->
    <span id="waveDisplay"></span> <!-- Renamed from #w -->
    <span id="healthDisplay"></span> <!-- Renamed from #h -->
</div>
<div id="startScreen"> <!-- Renamed from #s -->
    <h1>Orbital Defence Elite v2.41</h1>
    <button id="startButton">Start Game</button> <!-- Renamed from #b -->
    <button id="loadButton" style="display:none;">Load Game</button> <!-- Added Load Button -->
    <button id="clearSaveButton" style="display:none;">Clear Save</button>
    <button id="show-leaderboard">Leaderboard</button>
</div>
<div id="leaderboard-screen" style="display:none">
    <h1>Global Leaderboard</h1>
  <div id="leaderboard"></div>
  <div id="leaderboardLoading"></div>
  <button id="startFromHighScore">Start Game</button>
</div>
<div id="gameOverScreen" style="display:none"> <!-- Renamed from #o -->
    <h1 class="slow-blink">GAME OVER</h1>
    <p class="sub-message">You were defeated...</p>
    <div id="finalStats"></div> <!-- Renamed from #f -->
    <ol id="gameOverScoreList"></ol>
    <div id="cheekyMessage"></div>
    <input id="initialsInput" maxlength="3">
    <button id="restartButton">Play Again</button> <!-- Renamed from #r -->
</div>
<div id="controls">
    <button id="playPauseButton">&#9654;</button>
    <button id="slowDownButton">&#171;</button>
    <span id="speedDisplay">1x</span>
    <button id="speedUpButton">&#187;</button>
    <button id="macrossButton" style="display:none">Macross Missile Massacre</button> <!-- Renamed from #M -->
    <button id="toggleInfoButton" class="active">o</button> <!-- Renamed from #I -->
    <button id="themeButton">Theme: Orbital Elite</button> <!-- Added Theme Button -->
    <div id="sensorToggle">
        <span class="switch-label">Enemy Info:</span>
        <button id="sensorDisplayToggle">Hud</button>
    </div>
    <button id="fullscreenButton">&#x26F6;</button>
    <button id="muteButton">&#128266;</button>
    <button id="overlayButton">Overlay: None</button>
    <button id="sendWaveButton">Send Next Wave</button>
</div>
<div id="hotkeys" class="show">
    <div>H: Show/Hide Hotkeys</div>
    <div>WASD/Arrows/Drag: Move Base</div>
    <div>Click Base: Upgrades</div>
    <div>Click Ring UI: Quick Upgrade</div>
    <div>Space/Auto: Fire</div>
    <div>M: Macross Missiles</div>
    <div>F: Toggle Auto-fire</div>
    <div>I: Toggle Enemy Stats</div>
    <div>O: Toggle Ring Info</div>
</div>
<div id="enemyStatsPanel"><div id="enemyStatsHeader">Enemy Stats <span id="enemyStatsToggle" class="arrow">▾</span></div><div id="enemyStatsContent"></div></div>
<div id="sensorWarning" style="display:none">
    <p>The ring around your base shows your cannon's visual firing range. The cannon cannot target enemies beyond this radius. Click on the "Cannon" to upgrade the cannon's abilities.</p>
    <p>Upgrade "Sensors" Electronic FOV to see enemies outside this ring. The wave timer has started – enemies approach from beyond your sight.</p>
    <button id="sensorWarningButton">Continue</button>
</div>
<div id="enemyIdentificationPopup" style="display:none"><div class="card"><h2>Enemy Identified</h2><div id="enemyIntelContent"></div><button id="enemyIntelContinue">Continue</button></div></div>
<div id="toast"></div>
<!-- Removed shipSprite image as it wasn't used -->

<script>
// Orbital Defence Elite - Theme Definitions
// V2.30.1: Modified black and white themes to have white backgrounds
// V2.30: Added two new black and white themes
const THEMES = [
    { // Theme 1: Orbital Elite (Default)
        name: "Orbital Elite",
        cssVariables: {
            '--bg-gradient': 'linear-gradient(135deg, #0f2027, #203a43, #2c5364)',
            '--body-bg': '#000',
            '--text-color': '#fff',
            '--hud-color': '#fff',
            '--title-color': '#fff',
            '--final-stats-color': '#cfab52',
            '--button-bg': 'rgba(44, 34, 15, 1)',
            '--button-text': 'rgba(230, 181, 75, 1)',
            '--button-border': 'rgba(230, 181, 75, 1)',
            '--button-hover-bg': '#1c1404',
            '--button-disabled-bg': '#2f240c',
            '--button-disabled-text': '#ac4834',
            '--upgrade-title-color': 'rgba(230, 181, 75, 1)',
            '--toggle-active-bg': '#1c1404',
            '--toggle-active-text': '#e6b54b',
            '--toast-bg': 'rgba(0, 0, 0, 0.7)',
            '--toast-text': '#fff',
            '--switch-bg': '#2f240c',
            '--switch-slider-color': 'rgba(230, 181, 75, 1)',
            '--switch-checked-bg': '#1c1404',
            '--switch-label-color': 'rgba(230, 181, 75, 1)',
            '--stats-border': 'rgba(230, 181, 75, 0.3)',
            '--stats-bg': 'rgba(0, 0, 0, 0.4)',
            '--hotkey-bg': 'rgba(0, 0, 0, 0.6)',
            '--hotkey-text': 'rgba(230, 181, 75, 0.8)',
            '--canvas-bg': 'rgba(0, 0, 0, 0.7)',
            '--crt-overlay-bg': 'linear-gradient(rgba(0, 0, 0, 0.6) 50%, transparent 100%)',
            '--crt-overlay-blend': 'overlay',
            '--crt-scanline-color': 'rgba(0, 0, 0, 0.1)',
            '--crt-vignette': 'radial-gradient(circle at center, transparent 60%, rgba(0, 0, 0, 0.6) 100%)',
            '--crt-interlace-color': 'rgba(0, 0, 0, 0.25)',
            '--font-family': "'Share Tech Mono', monospace",
            '--button-font-size': '24px',
            '--upgrade-button-font-size': '16px',
            '--tab-font-size': '18px',
            '--ring-ui-font-size': '11px',
            '--hud-font-size': '28px',
            '--hotkey-font-size': '14px'
        },
        canvasColors: {
            base: 'rgb(94, 79, 162)',
            baseHit: 'yellow',
            bullet: 'white',
            missile: 'orange',
            macrossMissile: '#ff4500',
            missileTrail: 'rgba(255, 165, 0, 0.6)',
            laser: 'rgba(255, 0, 0, 0.8)',
            laserGlow: 'rgba(255, 255, 0, 0.6)',
            particleDefault: '#ffffff',
            particleHit: 'white',
            particleExplosion: ['#ffffff', '#ffff00'], // Base colors, actual color passed in
            particleStun: 'cyan',
            particleLaunch: 'orange',
            enemyNormal: '#f46d43',
            enemyFast: '#fee08b',
            enemyTank: '#d53e4f',
            enemyBoss: '#9e0142',
            enemyHealthBarBg: '#500',
            enemyHealthBarFg: '#0f0',
            enemyStunEffect: 'rgba(0, 255, 255, 0.8)',
            ringCannon: 'rgba(94, 79, 162, 0.6)',
            ringCannonUpgrade: 'rgba(148, 0, 211, 0.8)',
            ringMissile: 'rgba(50, 136, 189, 0.6)',
            ringMissileUpgrade: 'rgba(30, 144, 255, 0.8)',
            ringLaser: 'rgba(255, 0, 0, 0.5)',
            ringLaserUpgrade: 'rgba(255, 0, 0, 0.8)',
            ringStun: 'rgba(0, 255, 255, 0.5)',
            ringStunUpgrade: 'rgba(0, 255, 255, 0.8)',
            ringSensor: 'rgba(255, 200, 0, 0.6)',
            ringUpgradeBoxBg: 'rgba(50, 50, 50, 0.7)',
            ringUpgradeBoxAvailable: 'rgba(0, 255, 0, 0.7)',
            ringUpgradeBoxText: 'rgba(230, 181, 75, 1)',
            ringUpgradeBoxMax: 'rgba(230, 181, 75, 1)',
            gunBarrel: 'white',
            baseDragIndicator: 'rgba(200, 200, 255, 0.6)',
            baseReturnIndicator: 'rgba(120, 255, 120, 0.6)',
            upgradeRingLaser: 'rgba(255, 0, 0, 0.6)',
            upgradeRingMissile: 'rgba(255, 165, 0, 0.6)'
        },
        particlePalettes: { // For createParticle color mapping
            red: ['#ff0000', '#cc0000', '#880000', '#550000'],
            orange: ['#ff7700', '#cc5500', '#883300', '#552200'],
            yellow: ['#ffff00', '#cccc00', '#888800', '#555500'],
            white: ['#ffffff', '#cccccc', '#888888', '#555555'],
            cyan: ['#00ffff', '#00cccc', '#008888', '#005555']
        }
    },
    { // Theme 2: Vector Grid
        name: "Vector Grid",
        cssVariables: {
            '--bg-gradient': '#000000',
            '--body-bg': '#000',
            '--text-color': '#00ffcc',
            '--hud-color': '#00ffcc',
            '--title-color': '#ff00ff',
            '--final-stats-color': '#ffff00',
            '--button-bg': 'rgba(0, 0, 0, 0.5)',
            '--button-text': '#00ff00',
            '--button-border': '#00ff00',
            '--button-hover-bg': 'rgba(0, 50, 0, 0.8)',
            '--button-disabled-bg': 'rgba(0, 20, 0, 0.5)',
            '--button-disabled-text': '#008800',
            '--upgrade-title-color': '#ff00ff',
            '--toggle-active-bg': 'rgba(0, 50, 50, 0.8)',
            '--toggle-active-text': '#00ffff',
            '--toast-bg': 'rgba(0, 0, 0, 0.8)',
            '--toast-text': '#00ffcc',
            '--switch-bg': '#003322',
            '--switch-slider-color': '#00ff00',
            '--switch-checked-bg': '#005500',
            '--switch-label-color': '#00ffcc',
            '--stats-border': 'rgba(0, 255, 0, 0.5)',
            '--stats-bg': 'rgba(0, 0, 0, 0.6)',
            '--hotkey-bg': 'rgba(0, 0, 0, 0.7)',
            '--hotkey-text': '#00ffaa',
            '--canvas-bg': 'rgba(0, 0, 0, 0.9)',
            '--crt-overlay-bg': 'linear-gradient(rgba(0, 10, 0, 0.3) 50%, transparent 100%)',
            '--crt-overlay-blend': 'overlay',
            '--crt-scanline-color': 'rgba(0, 255, 0, 0.1)',
            '--crt-vignette': 'radial-gradient(circle at center, transparent 60%, rgba(0, 40, 0, 0.6) 100%)',
            '--crt-interlace-color': 'rgba(0, 255, 0, 0.25)',
            '--font-family': "'VT323', monospace",
            '--button-font-size': '38px',
            '--upgrade-button-font-size': '15px',
            '--tab-font-size': '22px',
            '--ring-ui-font-size': '19px',
            '--hud-font-size': '30px',
            '--hotkey-font-size': '18px'
        },
        canvasColors: {
            base: '#00ffcc',
            baseHit: '#00ffaa',
            bullet: '#00ff00',
            missile: '#00ff00',
            macrossMissile: '#ff00ff',
            missileTrail: 'rgba(0, 255, 0, 0.6)',
            laser: '#ff00ff',
            laserGlow: '#ffff00',
            particleDefault: '#00ffcc',
            particleHit: '#00ffcc',
            particleExplosion: ['#00ffcc', '#00ffaa'],
            particleStun: '#00ffaa',
            particleLaunch: '#00ffcc',
            enemyNormal: '#00ffaa',
            enemyFast: '#00ffcc',
            enemyTank: '#00ff88',
            enemyBoss: '#00ff00',
            enemyHealthBarBg: '#003300',
            enemyHealthBarFg: '#00ff00',
            enemyStunEffect: 'rgba(0, 255, 255, 0.8)',
            ringCannon: 'rgba(0, 255, 0, 0.6)',
            ringCannonUpgrade: 'rgba(0, 255, 100, 0.8)',
            ringMissile: 'rgba(0, 200, 255, 0.6)',
            ringMissileUpgrade: 'rgba(0, 150, 255, 0.8)',
            ringLaser: 'rgba(255, 0, 255, 0.5)',
            ringLaserUpgrade: 'rgba(255, 0, 255, 0.8)',
            ringStun: 'rgba(0, 255, 255, 0.5)',
            ringStunUpgrade: 'rgba(0, 255, 255, 0.8)',
            ringSensor: 'rgba(255, 200, 0, 0.6)',
            ringUpgradeBoxBg: 'rgba(0, 0, 0, 0.7)',
            ringUpgradeBoxAvailable: 'rgba(0, 255, 0, 0.7)',
            ringUpgradeBoxText: '#00ffcc',
            ringUpgradeBoxMax: '#00ffaa',
            gunBarrel: '#00ff00',
            baseDragIndicator: 'rgba(0, 255, 255, 0.6)',
            baseReturnIndicator: 'rgba(0, 255, 100, 0.6)'
        },
        particlePalettes: {
            red: ['#ff0000', '#cc0000', '#880000'],
            orange: ['#ff7700', '#cc5500', '#883300'],
            yellow: ['#ffff00', '#cccc00'],
            white: ['#ffffff', '#cccccc', '#888888'],
            cyan: ['#00ffff', '#00cccc']
        }
    },
    { // Theme 4: Pixel Black and White
        name: "Pixel Black and White",
        cssVariables: {
            '--bg-gradient': 'linear-gradient(135deg, #ffffff, #cccccc, #999999)',
            '--body-bg': '#fff',
            '--text-color': '#000',
            '--hud-color': '#000',
            '--title-color': '#000',
            '--final-stats-color': '#333333',
            '--button-bg': 'rgba(200, 200, 200, 1)',
            '--button-text': '#000000',
            '--button-border': '#000000',
            '--button-hover-bg': '#cccccc',
            '--button-disabled-bg': '#e6e6e6',
            '--button-disabled-text': '#999999',
            '--upgrade-title-color': '#000000',
            '--toggle-active-bg': '#cccccc',
            '--toggle-active-text': '#000000',
            '--toast-bg': 'rgba(255, 255, 255, 0.8)',
            '--toast-text': '#000',
            '--switch-bg': '#cccccc',
            '--switch-slider-color': '#000000',
            '--switch-checked-bg': '#999999',
            '--switch-label-color': '#000000',
            '--stats-border': 'rgba(0, 0, 0, 0.3)',
            '--stats-bg': 'rgba(255, 255, 255, 0.4)',
            '--hotkey-bg': 'rgba(255, 255, 255, 0.6)',
            '--hotkey-text': 'rgba(0, 0, 0, 0.8)',
            '--canvas-bg': 'rgba(255, 255, 255, 0.7)',
            '--crt-overlay-bg': 'linear-gradient(rgba(255, 255, 255, 0.6) 50%, transparent 100%)',
            '--crt-overlay-blend': 'overlay',
            '--crt-scanline-color': 'rgba(0, 0, 0, 0.1)',
            '--crt-vignette': 'radial-gradient(circle at center, transparent 60%, rgba(255, 255, 255, 0.6) 100%)',
            '--crt-interlace-color': 'rgba(0, 0, 0, 0.25)',
            '--font-family': "'Share Tech Mono', monospace",
            '--button-font-size': '20px',
            '--upgrade-button-font-size': '14px',
            '--tab-font-size': '16px',
            '--ring-ui-font-size': '9px',
            '--hud-font-size': '18px',
            '--hotkey-font-size': '12px'
        },
        canvasColors: {
            base: '#333333',
            baseHit: '#000000',
            bullet: '#000000',
            missile: '#333333',
            macrossMissile: '#000000',
            missileTrail: 'rgba(50, 50, 50, 0.6)',
            laser: 'rgba(0, 0, 0, 0.8)',
            laserGlow: 'rgba(50, 50, 50, 0.6)',
            particleDefault: '#000000',
            particleHit: '#000000',
            particleExplosion: ['#000000', '#333333'],
            particleStun: '#777777',
            particleLaunch: '#333333',
            enemyNormal: '#333333',
            enemyFast: '#000000',
            enemyTank: '#777777',
            enemyBoss: '#ffffff',
            enemyHealthBarBg: '#cccccc',
            enemyHealthBarFg: '#00ff00',
            enemyStunEffect: 'rgba(100, 100, 100, 0.8)',
            ringCannon: 'rgba(100, 100, 100, 0.6)',
            ringCannonUpgrade: 'rgba(50, 50, 50, 0.8)',
            ringMissile: 'rgba(150, 150, 150, 0.6)',
            ringMissileUpgrade: 'rgba(100, 100, 100, 0.8)',
            ringLaser: 'rgba(50, 50, 50, 0.5)',
            ringLaserUpgrade: 'rgba(0, 0, 0, 0.8)',
            ringStun: 'rgba(100, 100, 100, 0.5)',
            ringStunUpgrade: 'rgba(50, 50, 50, 0.8)',
            ringSensor: 'rgba(255, 200, 0, 0.6)',
            ringUpgradeBoxBg: 'rgba(200, 200, 200, 0.7)',
            ringUpgradeBoxAvailable: 'rgba(0, 255, 0, 0.7)',
            ringUpgradeBoxText: '#000000',
            ringUpgradeBoxMax: '#333333',
            gunBarrel: '#000000',
            baseDragIndicator: 'rgba(50, 50, 50, 0.6)',
            baseReturnIndicator: 'rgba(100, 100, 100, 0.6)'
        },
        particlePalettes: {
            red: ['#000000', '#333333', '#777777'],
            orange: ['#333333', '#777777', '#aaaaaa'],
            yellow: ['#000000', '#333333'],
            white: ['#000000', '#333333', '#777777', '#aaaaaa'],
            cyan: ['#333333', '#777777']
        }
    },
    { // Theme 5: Service HUD
        name: "Service HUD",
        cssVariables: {
            '--bg-gradient': '#0a0f13',
            '--body-bg': '#0a0f13',
            '--text-color': '#e2eaf3',
            '--hud-color': '#64f58d',
            '--title-color': '#00ffe1',
            '--final-stats-color': '#f3c400',
            '--button-bg': '#1b2a33',
            '--button-text': '#00ffe1',
            '--button-border': '#00ffe1',
            '--button-hover-bg': '#64f58d',
            '--button-disabled-bg': '#1b2a33',
            '--button-disabled-text': '#8899a6',
            '--upgrade-title-color': '#f3c400',
            '--toggle-active-bg': '#1b2a33',
            '--toggle-active-text': '#64f58d',
            '--toast-bg': 'rgba(10, 15, 19, 0.9)',
            '--toast-text': '#e2eaf3',
            '--switch-bg': '#1b2a33',
            '--switch-slider-color': '#00ffe1',
            '--switch-checked-bg': '#64f58d',
            '--switch-label-color': '#e2eaf3',
            '--stats-border': '#2194f3',
            '--stats-bg': 'rgba(255,255,255,0.06)',
            '--hotkey-bg': 'rgba(255,255,255,0.06)',
            '--hotkey-text': '#8899a6',
            '--canvas-bg': '#0a0f13',
            '--crt-overlay-bg': 'linear-gradient(rgba(0,255,255,0.06) 50%, transparent 100%)',
            '--crt-overlay-blend': 'overlay',
            '--crt-scanline-color': 'rgba(255, 255, 255, 0.05)',
            '--crt-vignette': 'radial-gradient(circle, transparent 60%, rgba(0,0,0,0.5) 100%)',
            '--crt-interlace-color': 'rgba(255, 255, 255, 0.05)',
            '--font-family': "'Rajdhani', 'Share Tech Mono', monospace",
            '--button-font-size': '24px',
            '--upgrade-button-font-size': '16px',
            '--tab-font-size': '14px',
            '--ring-ui-font-size': '11px',
            '--hud-font-size': '28px',
            '--hotkey-font-size': '14px'
        },
        canvasColors: {
            base: '#64f58d',
            baseHit: '#fca311',
            bullet: '#00ffe1',
            missile: '#fca311',
            macrossMissile: '#f3c400',
            missileTrail: 'rgba(252,163,17,0.6)',
            laser: '#2194f3',
            laserGlow: 'rgba(0,255,225,0.6)',
            particleDefault: '#e2eaf3',
            particleHit: '#00ffe1',
            particleExplosion: ['#f3c400', '#fca311'],
            particleStun: '#00ffe1',
            particleLaunch: '#64f58d',
            enemyNormal: '#fca311',
            enemyFast: '#2194f3',
            enemyTank: '#f3c400',
            enemyBoss: '#64f58d',
            enemyHealthBarBg: '#1b2a33',
            enemyHealthBarFg: '#64f58d',
            enemyStunEffect: 'rgba(0,255,225,0.8)',
            ringCannon: 'rgba(100,245,141,0.6)',
            ringCannonUpgrade: 'rgba(100,245,141,0.8)',
            ringMissile: 'rgba(252,163,17,0.6)',
            ringMissileUpgrade: 'rgba(252,163,17,0.8)',
            ringLaser: 'rgba(33,148,243,0.5)',
            ringLaserUpgrade: 'rgba(33,148,243,0.8)',
            ringStun: 'rgba(0,255,225,0.5)',
            ringStunUpgrade: 'rgba(0,255,225,0.8)',
            ringSensor: 'rgba(243,196,0,0.6)',
            ringUpgradeBoxBg: 'rgba(255,255,255,0.06)',
            ringUpgradeBoxAvailable: 'rgba(100,245,141,0.7)',
            ringUpgradeBoxText: '#e2eaf3',
            ringUpgradeBoxMax: '#f3c400',
            gunBarrel: '#e2eaf3',
            baseDragIndicator: 'rgba(0,255,225,0.6)',
            baseReturnIndicator: 'rgba(100,245,141,0.6)',
            upgradeRingLaser: 'rgba(33,148,243,0.6)',
            upgradeRingMissile: 'rgba(252,163,17,0.6)'
        },
        particlePalettes: {
            red: ['#fca311', '#d98a0e', '#b3720b', '#8c5b08'],
            orange: ['#f3c400', '#cfa700', '#a58200', '#7b5e00'],
            yellow: ['#f3c400', '#cfa700', '#a58200', '#7b5e00'],
            white: ['#e2eaf3', '#bfc8d4', '#8a959f', '#5b6066'],
            cyan: ['#00ffe1', '#00ccb4', '#008b7a', '#005540']
        }
    }
];
</script>
<script defer>
(function(){ // IIFE to encapsulate code
"use strict";
let currentThemeIndex = 0;
let currentTheme = THEMES[currentThemeIndex];

// --- Configuration Constants ---

const CONFIG = {
    ENEMY_HEALTH_SCALE_FACTOR: 1.25,
    BULLET_BASE_SPEED: 5,
    BASE_RADIUS: 30,
    INITIAL_FIRE_RATE: 200,
    MACROSS_BASE_COOLDOWN: 30,
    MACROSS_COOLDOWN_REDUCTION_PER_LEVEL: 3,
    PARTICLE_BASE_SPEED: 1,
    PARTICLE_BASE_LIFE: 1,
    PARTICLE_BASE_SIZE: 2,
    WAVE_BASE_DURATION: 60, // seconds
    WAVE_DURATION_INCREMENT: 10, // seconds per wave
    BOSS_HEALTH_BASE: 20,
    BOSS_HEALTH_WAVE_MULTIPLIER: 10,
    BOSS_RADIUS_INCREMENT: 2,
    MAX_ENEMY_COUNT: 30, // Increased from 20
    BASE_INITIAL_MOVE_SPEED: 2,
    BASE_MOVE_SPEED_INCREMENT: 1,
    MISSILE_FIRE_INTERVAL: 2000, // ms
    LASER_FIRE_INTERVAL: 500, // ms
    STUN_EFFECT_DURATION: 2000, // ms
    TARGET_LOCK_DURATION: 300, // ms brackets stay red this long after targeting
    AUTO_SAVE_INTERVAL: 60000, // ms (1 minute)
    DRAG_THRESHOLD: 5, // pixels to initiate drag vs click (default)
    CANVAS_CLICK_TOLERANCE: 20 // pixels tolerance for clicking ring UI
};
// Increase drag threshold on touch devices to make tapping upgrades easier
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
if (isTouchDevice) {
    CONFIG.DRAG_THRESHOLD = 20;
}
const {
  ENEMY_HEALTH_SCALE_FACTOR,
  BULLET_BASE_SPEED,
  BASE_RADIUS,
  INITIAL_FIRE_RATE,
  MACROSS_BASE_COOLDOWN,
  MACROSS_COOLDOWN_REDUCTION_PER_LEVEL,
  PARTICLE_BASE_SPEED,
  PARTICLE_BASE_LIFE,
  PARTICLE_BASE_SIZE,
  WAVE_BASE_DURATION,
  WAVE_DURATION_INCREMENT,
  BOSS_HEALTH_BASE,
  BOSS_HEALTH_WAVE_MULTIPLIER,
  BOSS_RADIUS_INCREMENT,
  MAX_ENEMY_COUNT,
  BASE_INITIAL_MOVE_SPEED,
  BASE_MOVE_SPEED_INCREMENT,
  MISSILE_FIRE_INTERVAL,
  LASER_FIRE_INTERVAL,
  STUN_EFFECT_DURATION,
  TARGET_LOCK_DURATION,
  AUTO_SAVE_INTERVAL,
  DRAG_THRESHOLD,
  CANVAS_CLICK_TOLERANCE
} = CONFIG;
// Upgrade Category Indices
const UPGRADE_CATEGORY_CANNON = 0;
const UPGRADE_CATEGORY_DEFENSE = 1;
const UPGRADE_CATEGORY_LASER = 2;
const UPGRADE_CATEGORY_MISSILE = 3;
const UPGRADE_CATEGORY_SPECIAL = 4;
const UPGRADE_CATEGORY_SENSORS = 5;
const UPGRADE_CATEGORY_DEBUG = 6;

// Specific Upgrade Indices (within category)
const UPGRADE_CANNON_FIRERATE = 0;
const UPGRADE_CANNON_DAMAGE = 1;
const UPGRADE_CANNON_RANGE = 2;
const UPGRADE_CANNON_MULTIBARREL = 3;
const UPGRADE_CANNON_FOCUS_RADIUS = 4;
const UPGRADE_DEFENSE_HEALTH = 0;
const UPGRADE_DEFENSE_MOVEMENT = 1;
const UPGRADE_LASER_DAMAGE = 0; // Only one laser upgrade
const UPGRADE_LASER_MANUAL = 1; // Manual laser targeting
const UPGRADE_MISSILE_COUNT = 0;
const UPGRADE_MISSILE_RANGE = 1;
const UPGRADE_MISSILE_DAMAGE = 2;
const UPGRADE_MISSILE_HOMING = 3;
const UPGRADE_MISSILE_MACROSS = 4;
const UPGRADE_SPECIAL_STUN = 0;
const UPGRADE_SENSOR_RANGE = 0;
const UPGRADE_SENSOR_OUTLINES = 1;
const UPGRADE_SENSOR_HEALTHBARS = 2;
const UPGRADE_SENSOR_TARGET_AI = 3;

// Enemy types: [color, speed, health, radius, credits]
const ENEMY_TYPES = [
  ['#f46d43', 1,   3, 10,  10], // Normal
  ['#fee08b', 2,   2,  8,  20], // Fast
  ['#d53e4f', 0.5, 6, 15,  30], // Tank
  ['#9e0142', 0.3, 0, 25, 100]  // Boss (health calculated dynamically)
];
const ENEMY_TYPE_NORMAL = 0;
const ENEMY_TYPE_FAST = 1;
const ENEMY_TYPE_TANK = 2;
const ENEMY_TYPE_BOSS = 3;

// Helper for getting DOM elements
const getElement = id => document.getElementById(id);

// --- Canvas & Context ---
const canvas = getElement('gameCanvas');
const ctx = canvas.getContext('2d');
let canvasWidth = window.innerWidth;
let canvasHeight = window.innerHeight;
canvas.width = canvasWidth;
canvas.height = canvasHeight;

// --- Game State Variables ---
let showRingInfo = true;
let showMissileRadius = false;
let sensorUpgrades = { enemyVisuals: false, showHealthBars: false, targetAI: false };
let sensorDisplayMode = 'hud';
let baseCanMove = true;
let enemyIntel = { active:false, known:{}, order:[] };
let keysPressed = {};
let particles = [];
let lastTime = 0;
let deltaTime = 0;
let gameState; // Contains credits, health, wave, score etc.
let gameStartTime = 0;
let base; // Contains position, stats, upgrades effects
let upgradeTree; // Defines upgrade structure, costs, effects
const SPEED_STEPS = [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,1.5,2,3,4,5,6,7,8,9,10];
let speedIndex = SPEED_STEPS.indexOf(1);
let gameSpeedMultiplier = SPEED_STEPS[speedIndex];
let isGameRunning = false;
let isMuted = localStorage.getItem('ode_isMuted') === 'true';
let animationFrameId = null;
let savedGame = null; // Stores loaded game state
let autoSaveTimer = null;
let DEBUG_MODE = false; // Set to true to enable verbose logging
let debugUpgradesVisible = false; // Hidden debug upgrade category toggle
let lastBaseX = 0;
let lastBaseY = 0;
window.pendingScore = null; // Store score awaiting initials
let isDeathSequence = false; // True during slow-motion before game over
let deathSequenceStartTime = 0;

// Dragging State
let isDragging = false;
let dragStartX = 0;
let dragStartY = 0;
let baseStartX = 0;
let baseStartY = 0;
let isReturningToCenter = false;
let wasDragging = false; // Used to differentiate click from drag-release
let centerReturnSpeed = 0.5;
let centerReturnStartTime = 0;

// Ring UI Clickable Regions (calculated during draw)
let ringClickRegions = [];

let xpCardShown = false;

// Track which waves are currently active and whether their bosses live
let activeWaves = [];
let waveBossAlive = {};

// Cache width of the hotkeys panel for enemy stats alignment
let hotkeysWidth = null;


// --- Overlay System ---
const OVERLAY_METHODS = ['None','Canvas','CSS','Fog'];
let overlayMode = 0;
let fogCanvas = null, fogCtx = null;
let cssOverlay = null, overlayButton = null;
const UPGRADE_MASK_WIDTH = 600; // width of the left-side upgrade panel

function cycleOverlay() {
    overlayMode = (overlayMode + 1) % OVERLAY_METHODS.length;
    if (overlayButton) overlayButton.textContent = 'Overlay: ' + OVERLAY_METHODS[overlayMode];
    if (cssOverlay) cssOverlay.style.display = overlayMode === 2 ? 'block' : 'none';
}


function applyOverlay(radius) {
    switch (overlayMode) {
        case 1:
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.6)';
            ctx.fillRect(0,0,canvasWidth,canvasHeight);
            ctx.globalCompositeOperation = 'destination-out';
            ctx.beginPath();
            ctx.arc(base.x, base.y, radius, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
            break;
        case 2:
            if (cssOverlay) {
                const radial = `radial-gradient(circle at ${base.x}px ${base.y}px, transparent 0, transparent ${radius}px, black ${radius}px)`;
                const rect = 'linear-gradient(black, black)';
                const mask = `${radial}, ${rect}`;
                cssOverlay.style.maskImage = mask;
                cssOverlay.style.webkitMaskImage = mask;
                cssOverlay.style.maskSize = `100% 100%, ${UPGRADE_MASK_WIDTH}px 100%`;
                cssOverlay.style.webkitMaskSize = `100% 100%, ${UPGRADE_MASK_WIDTH}px 100%`;
                cssOverlay.style.maskPosition = `0 0, 0 0`;
                cssOverlay.style.webkitMaskPosition = `0 0, 0 0`;
                cssOverlay.style.maskRepeat = 'no-repeat, no-repeat';
                cssOverlay.style.webkitMaskRepeat = 'no-repeat, no-repeat';
                cssOverlay.style.maskComposite = 'subtract';
                cssOverlay.style.webkitMaskComposite = 'xor';
            }
            break;
        case 3:
            if (!fogCanvas) {
                fogCanvas = document.createElement('canvas');
                fogCanvas.width = canvasWidth;
                fogCanvas.height = canvasHeight;
                fogCtx = fogCanvas.getContext('2d');
            }
            fogCtx.clearRect(0,0,canvasWidth,canvasHeight);
            fogCtx.fillStyle = 'rgba(0,0,0,0.8)';
            fogCtx.fillRect(0,0,canvasWidth,canvasHeight);
            fogCtx.globalCompositeOperation = 'destination-out';
            fogCtx.beginPath();
            fogCtx.arc(base.x, base.y, radius, 0, Math.PI*2);
            fogCtx.fill();
            fogCtx.globalCompositeOperation = 'source-over';
            ctx.drawImage(fogCanvas,0,0);
            break;
    }
}

// --- Object Pooling ---
const ObjectPool = function(objectType, initialSize = 20, resetFunction) {
    let pool = [];
    let active = [];

    // Pre-populate the pool
    for (let i = 0; i < initialSize; i++) {
        pool.push(new objectType());
    }

    return {
        get: function(config = {}) {
            let obj = pool.length > 0 ? pool.pop() : new objectType();
            // Apply specific config
            Object.assign(obj, config);
            // Apply general reset if provided (or could be part of config)
            if (resetFunction) {
                resetFunction(obj, config); // Pass config in case reset depends on it
            }
            active.push(obj);
            return obj;
        },
        release: function(obj) {
            let index = active.indexOf(obj);
            if (index !== -1) {
                active.splice(index, 1);
                // Apply reset function before putting back in pool
                if (resetFunction) {
                    resetFunction(obj, {}); // Reset to default state
                }
                pool.push(obj);
            }
        },
        getActiveObjects: function() {
            return active;
        },
        clear: function() {
            pool = pool.concat(active);
            active = [];
            // Ensure all objects in the pool are reset
            if (resetFunction) {
                pool.forEach(obj => resetFunction(obj, {}));
            }
        }
    };
};

// --- Object Pool Reset Functions ---
function resetEnemy(enemy, config) {
    // Reset common properties
    enemy.x = config.x || 0;
    enemy.y = config.y || 0;
    enemy.color = config.c || '#ffffff';
    enemy.speed = config.s || 0;
    enemy.normalSpeed = config.s || 0;
    enemy.health = config.h || 1;
    enemy.maxHealth = config.m || 1;
    enemy.radius = config.r || 10;
    enemy.creditsValue = config.C || 0;
    enemy.trail = config.T || []; // Ensure trail is reset or set
    enemy.isStunned = config.st || false;
    enemy.stunTime = config.stunTime || 0;
    enemy.type = config.type || 'Normal';
    enemy.xp = config.xp || false;
    enemy.dir = config.dir || 1;
    enemy.wave = config.wave || 0;

    enemy.isTargeted = false;
    enemy.targetLockTime = 0;

    enemy.allocatedDamage = 0;

    // Clear dynamic properties
    enemy.trail = [];
    enemy.isStunned = false;
    enemy.stunTime = 0;
}

function resetBullet(bullet, config) {
    bullet.x = config.x || 0;
    bullet.y = config.y || 0;
    bullet.dx = config.dx || 0;
    bullet.dy = config.dy || 0;
    bullet.color = config.color || currentTheme.canvasColors.bullet;
}

function resetMissile(missile, config) {
    const isRelease = !config || Object.keys(config).length === 0;

    missile.x = config.x || 0;
    missile.y = config.y || 0;
    missile.dx = config.dx || 0;
    missile.dy = config.dy || 0;
    missile.target = config.t || null; // Set target or null
    missile.speed = config.speed || 1;
    missile.turnSpeed = config.turnSpeed || 0.05;
    missile.homingRadius =
        typeof config.homingRadius !== 'undefined' ? config.homingRadius : base.missileHomingRadius;
    missile.trail = config.trail || Array(40).fill({ x: missile.x, y: missile.y });
    missile.isMacross = config.macross || false;
    missile.homingActive = config.homingActive || false;
    missile.startX = config.startX || missile.x;
    missile.startY = config.startY || missile.y;
    missile.rangeLimit = config.rangeLimit || base.missileTargetingRadius * 1.1;

    if (isRelease) {
        // When releasing back to the pool, clear dynamic state
        missile.target = null;
        missile.trail = [];
        missile.isMacross = false;
        missile.homingActive = false;
        missile.homingRadius = base.missileHomingRadius;
        missile.startX = 0;
        missile.startY = 0;
        missile.rangeLimit = base.missileTargetingRadius * 1.1;
    }
}


// Initialize object pools
const enemyPool = ObjectPool(Object, 50, resetEnemy); // Increased pool size
const bulletPool = ObjectPool(Object, 150, resetBullet); // Increased pool size
const missilePool = ObjectPool(Object, 75, resetMissile); // Increased pool size

// Reset pools function
function resetPools() {
    enemyPool.clear();
    bulletPool.clear();
    missilePool.clear();
    particles = [];
}

// --- Particle System ---
function createParticle(x, y, color, speed = PARTICLE_BASE_SPEED, life = PARTICLE_BASE_LIFE, size = PARTICLE_BASE_SIZE) {
    // Use theme's particle palettes
    const themePalettes = currentTheme.particlePalettes;
    let palette;

    // Basic color matching (can be improved)
    if (color === 'white' || color === '#ffffff') palette = themePalettes.white;
    else if (color === 'yellow' || color === '#ffff00') palette = themePalettes.yellow;
    else if (color === 'red' || color === '#ff0000') palette = themePalettes.red;
    else if (color === 'orange' || color === '#ff7700') palette = themePalettes.orange;
    else if (color === 'cyan' || color === '#00ffff') palette = themePalettes.cyan;
    else {
        // Attempt to find a matching palette based on hex/rgb similarity (simplified)
        if (color.includes('f00') || color.includes('800')) palette = themePalettes.red;
        else if (color.includes('ff0') || color.includes('cc0')) palette = themePalettes.yellow;
        else if (color.includes('f70') || color.includes('f90')) palette = themePalettes.orange;
        else if (color.includes('0ff') || color.includes('0cc')) palette = themePalettes.cyan;
        else palette = themePalettes.white; // Default to white palette
    }

    // Ensure palette exists, fallback if necessary
    if (!palette || palette.length === 0) {
        palette = ['#FFFFFF']; // Fallback to pure white if theme palette is missing/empty
    }

    const selectedColor = palette[Math.floor(Math.random() * palette.length)];

    particles.push({
        x: Math.floor(x), // Keep particles pixel-aligned
        y: Math.floor(y),
        vx: Math.floor((Math.random() - 0.5) * speed * 2) / 2,
        vy: Math.floor((Math.random() - 0.5) * speed * 2) / 2,
        size: Math.max(1, Math.floor(size)),
        color: selectedColor,
        alpha: 1,
        life: life,
        maxLife: life
    });
}

function shadeColor(color, percent) {
    if (color.startsWith('#')) color = color.slice(1);
    if (color.toLowerCase() === 'white') color = 'ffffff';
    let num = parseInt(color, 16);
    let r = (num >> 16) + percent;
    let g = ((num >> 8) & 0x00ff) + percent;
    let b = (num & 0x0000ff) + percent;
    r = Math.min(255, Math.max(0, r));
    g = Math.min(255, Math.max(0, g));
    b = Math.min(255, Math.max(0, b));
    return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
}
function colorWithAlpha(color, alpha){
    const m=color.match(/rgba?\(([^)]+)\)/);
    if(m){
        const parts=m[1].split(/,s*/);
        return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
    }
    return color;
}

function getCategoryColor(index){
    switch(index){
        case UPGRADE_CATEGORY_CANNON: return currentTheme.canvasColors.ringCannon;
        case UPGRADE_CATEGORY_LASER: return currentTheme.canvasColors.ringLaser;
        case UPGRADE_CATEGORY_MISSILE: return currentTheme.canvasColors.ringMissile;
        case UPGRADE_CATEGORY_SPECIAL: return currentTheme.canvasColors.ringStun;
        case UPGRADE_CATEGORY_SENSORS: return currentTheme.canvasColors.ringSensor || currentTheme.canvasColors.ringCannon;
        default: return currentTheme.canvasColors.ringCannon;
    }
}

function createExplosion(x, y, color, count = 15, enemyRadius = 10) {
    const baseSize = Math.max(2, Math.floor(enemyRadius / 3));
    const particleCount = Math.max(5, Math.floor(count * (enemyRadius / 10)));
    const ringCount = Math.floor(enemyRadius / 2);

    // Outer ring
    for (let i = 0; i < ringCount; i++) {
        const angle = (i / ringCount) * Math.PI * 2;
        const distance = enemyRadius * 0.8;
        createParticle(x + Math.cos(angle) * distance, y + Math.sin(angle) * distance, color, 2 + enemyRadius / 10, 0.6, baseSize);
    }

    // Core explosion
    for (let i = 0; i < particleCount; i++) {
        let particleColor = (i < particleCount * 0.2) ? '#ffffff' : (i < particleCount * 0.5) ? '#ffff00' : color;
        const distanceFactor = Math.random() * 0.8;
        const speed = 3 + (enemyRadius / 10) * (1 - distanceFactor);
        const particleSize = baseSize * (1 + (1 - i / particleCount));
        createParticle(
            x + (Math.random() - 0.5) * enemyRadius * distanceFactor,
            y + (Math.random() - 0.5) * enemyRadius * distanceFactor,
            particleColor, speed, 0.3 + Math.random() * 0.4, particleSize
        );
    }
}

function updateParticles(dt) {
    const dtScaled = dt * 60;
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dtScaled;
        p.y += p.vy * dtScaled;
        p.life -= dt;
        p.alpha = Math.max(0, p.life / p.maxLife); // Ensure alpha doesn't go negative

        if (p.life <= 0) {
            particles.splice(i, 1);
        }
    }
}

function drawParticles() {
    if (particles.length === 0) return;
    // Batch drawing by color for potential minor optimization
    const particlesByColor = {};
    particles.forEach(p => {
        if (!particlesByColor[p.color]) {
            particlesByColor[p.color] = [];
        }
        particlesByColor[p.color].push(p);
    });

    ctx.globalAlpha = 1; // Reset global alpha once
    for (const color in particlesByColor) {
        ctx.fillStyle = color;
        particlesByColor[color].forEach(p => {
            // Apply alpha individually if needed, though batching might be less effective then
            // ctx.globalAlpha = p.alpha; // Uncomment if alpha varies significantly per particle
            const pixelX = Math.floor(p.x);
            const pixelY = Math.floor(p.y);
            ctx.fillRect(pixelX, pixelY, p.size, p.size);
        });
    }
    // ctx.globalAlpha = 1; // Reset alpha if applied individually
}

function drawBracket(x, y, size, color = '#ffcc00', pulsing = true) {
    const pulse = pulsing ? 1 + 0.1 * Math.sin(Date.now() / 200) : 1;
    const s = size * pulse;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - s, y - s * 0.6); ctx.lineTo(x - s, y - s); ctx.lineTo(x - s * 0.6, y - s);
    ctx.moveTo(x + s, y - s * 0.6); ctx.lineTo(x + s, y - s); ctx.lineTo(x + s * 0.6, y - s);
    ctx.moveTo(x - s, y + s * 0.6); ctx.lineTo(x - s, y + s); ctx.lineTo(x - s * 0.6, y + s);
    ctx.moveTo(x + s, y + s * 0.6); ctx.lineTo(x + s, y + s); ctx.lineTo(x + s * 0.6, y + s);
    ctx.stroke();
}

// --- Enemy Spawning ---
function spawnEnemy(isBoss = false) {
    const spawnAngle = Math.random() * Math.PI * 2;
    const spawnRadius = Math.max(canvasWidth, canvasHeight) / 2 + 50; // Spawn slightly off-screen
    const enemyTypeIndex = isBoss ? ENEMY_TYPE_BOSS : Math.floor(Math.random() * ENEMY_TYPE_BOSS); // Don't randomly spawn boss
    const enemyTemplate = ENEMY_TYPES[enemyTypeIndex];
    const difficultyScaling = Math.pow(ENEMY_HEALTH_SCALE_FACTOR, gameState.wave - 1);

    let health, speed, credits, radius = enemyTemplate[3];
    if (isBoss) {
        health = (BOSS_HEALTH_BASE + gameState.wave * BOSS_HEALTH_WAVE_MULTIPLIER) * difficultyScaling;
        speed = enemyTemplate[1] * Math.sqrt(difficultyScaling); // Boss gets faster too
        credits = Math.floor(enemyTemplate[4] * Math.sqrt(difficultyScaling) * 5); // Boss gives more credits
        radius += (gameState.wave - 1) * BOSS_RADIUS_INCREMENT;
    } else {
        health = enemyTemplate[2] * difficultyScaling;
        speed = enemyTemplate[1] * Math.sqrt(difficultyScaling);
        credits = Math.floor(enemyTemplate[4] * Math.sqrt(difficultyScaling));
    }

    const enemy = enemyPool.get({
        x: base.x + Math.cos(spawnAngle) * spawnRadius,
        y: base.y + Math.sin(spawnAngle) * spawnRadius,
        c: enemyTemplate[0], // color
        s: speed,
        h: health,
        m: health,
        r: radius,
        C: credits, // creditsValue
        T: [], // trail
        st: false, // isStunned
        stunTime: 0,
        type: isBoss ? 'Boss' : (enemyTypeIndex === ENEMY_TYPE_TANK ? 'Tank' : (enemyTypeIndex === ENEMY_TYPE_FAST ? 'Fast' : 'Normal')),
        wave: gameState.wave
    });

    if (isBoss) {
        waveBossAlive[gameState.wave] = true;
    }

    if (enemyIntel.active && enemyIntel.known[enemy.type]) {
        enemyIntel.known[enemy.type].health = Math.round(health);
        updateEnemyStatsPanel();
    }
    gameState.enemiesSpawnedThisWave++;
}

function spawnXPEnemy() {
    const y = base.y - canvasHeight / 2 + 40;
    enemyPool.get({
        x: base.x - canvasWidth / 2 - 30,
        y,
        c: '#00ffff',
        s: 2,
        h: 5,
        m: 5,
        r: 12,
        C: 0,
        xp: true,
        dir: 1,
        type: 'XP',
        wave: gameState.wave
    });
}

function handleEnemyKilled(enemy) {
    if (enemy.type === 'Boss') {
        waveBossAlive[enemy.wave] = false;
        enemyPool.getActiveObjects().forEach(e => {
            if (e.xp) enemyPool.release(e);
        });
    }
    const enemies = enemyPool.getActiveObjects();
    if (!enemies.some(e => e.wave === enemy.wave)) {
        const idx = activeWaves.indexOf(enemy.wave);
        if (idx !== -1) activeWaves.splice(idx, 1);
    }
    updateHUD();
}

// --- UI & HUD Updates ---
function showToast(message, duration = 2000) {
    const toast = getElement('toast');
    toast.textContent = message;
    toast.classList.add('show');

    setTimeout(() => {
        toast.classList.remove('show');
    }, duration);
}
window.showToast = showToast;

function playSound(audio) {
    if (isMuted) return;
    if (audio && typeof audio.play === 'function') {
        audio.currentTime = 0;
        audio.play();
    }
}

function renderScoreList(id, scores, highlightIndex = -1) {
    const list = getElement(id);
    list.textContent = '';
    if (scores.length === 0) {
        const li = document.createElement('li');
        li.textContent = 'No scores yet';
        list.appendChild(li);
    }
    for (let i = 0; i < 10; i++) {
        const li = document.createElement('li');
        const entry = scores[i]
            ? `${scores[i].initials} - Wave ${scores[i].wave} (${scores[i].time ?? 0}s left) - ${scores[i].date}`
            : "&nbsp;";
        const rankSpan = document.createElement('span');
        rankSpan.className = 'rank';
        rankSpan.textContent = `${i + 1}.`;
        li.appendChild(rankSpan);
        li.appendChild(document.createTextNode(' ' + (entry === "&nbsp;" ? "\u00A0" : entry)));
        if (i === highlightIndex) li.classList.add('highlight');
        list.appendChild(li);
    }
}

function showHighScores() {
    getElement('startScreen').style.display = 'none';
    getElement('gameOverScreen').style.display = 'none';
    getElement('leaderboard-screen').style.display = 'flex';
    getElement('leaderboardLoading').style.display = 'block';
    getElement('deathOverlay').style.display = 'none';
    listenToLeaderboard(renderLeaderboard);
}

// Expose for module script
window.showHighScores = showHighScores;

function showSensorWarning() {
    getElement('sensorWarning').style.display = 'flex';
}

function dismissSensorWarning() {
    getElement('sensorWarning').style.display = 'none';
    if (!gameStartTime) gameStartTime = Date.now();
    gameState.waveStartTime = Date.now();
    gameState.waveElapsedTime = 0;
    gameState.waveDuration = WAVE_BASE_DURATION + (gameState.wave - 1) * WAVE_DURATION_INCREMENT;
    gameState.xpEnemySpawned = false;
    gameState.xpEnemySpawnTime = Math.random() * (gameState.waveDuration - 2);
    resumeGame();
    showToast('Wave timer started! Enemies approaching just outside your range.', 3000);
}

async function submitInitials() {
    let initials = getElement('initialsInput').value.toUpperCase().replace(/[^A-Z0-9]/g, '');
    if (initials.length === 2) initials += '_';
    if (initials.length < 2) return;
    if (!window.pendingScore) return;
    const { wave, time, ranking } = window.pendingScore;
    try {
        await submitScore({ initials, wave, time, ranking });
        showToast('Score submitted!');
        getElement('initialsInput').style.display = 'none';
        window.pendingScore.saved = true;
        const scores = await getTopScores();
        const index = scores.findIndex(s => s.ranking === ranking && s.initials === initials);
        renderScoreList('gameOverScoreList', scores, index);
        const position = index + 1;
        if (position > 0) {
            getElement('cheekyMessage').textContent = `You placed #${position}!`;
        }
    } catch (err) {
        console.error('Failed to submit score', err);
        showToast('Error saving score', 3000);
    }
}

function updateHUD() {
    getElement('creditsDisplay').textContent = `Credits: ${gameState.credits}`;
    getElement('healthDisplay').textContent = `Health: ${Math.max(0, gameState.currentHealth)}/${gameState.maxHealth}`; // Ensure health doesn't show < 0

    const elapsedTime = gameState.waveElapsedTime;
    let countdownText;

    if (gameState.isBossWave) {
        countdownText = "Boss!";
    } else {
        const remainingTime = Math.max(0, gameState.waveDuration - elapsedTime);
        const minutes = Math.floor(remainingTime / 60);
        const seconds = Math.floor(remainingTime % 60);
        countdownText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    const waveText = gameState.wave;
    getElement('waveDisplay').textContent = `Wave: ${waveText} | ${countdownText}`;

}



function updateSpeedDisplay() {
    const val = SPEED_STEPS[speedIndex];
    const text = Number.isInteger(val) ? val.toString() : val.toFixed(1);
    getElement('speedDisplay').textContent = `${text}x`;
}

function pauseGame() {
    if (!isGameRunning) return;
    isGameRunning = false;
    cancelAnimationFrame(animationFrameId);
    if (autoSaveTimer) clearInterval(autoSaveTimer);
    getElement('playPauseButton').textContent = '\u25B6';
}

function resumeGame() {
    if (isGameRunning) return;
    gameSpeedMultiplier = 1;
    speedIndex = SPEED_STEPS.indexOf(1);
    updateSpeedDisplay();
    isGameRunning = true;
    lastTime = 0;
    animationFrameId = requestAnimationFrame(gameLoop);
    if (autoSaveTimer) clearInterval(autoSaveTimer);
    autoSaveTimer = setInterval(() => { if (isGameRunning) saveGame(); }, AUTO_SAVE_INTERVAL);
    getElement('playPauseButton').textContent = '\u23F8';
}

// --- Game State Management ---
function saveGame() {
    const gameStateData = {
        gameState: { ...gameState },
        base: { ...base },
        upgrades: upgradeTree.map(category => ({
            category: category.category,
            upgrades: category.upgrades.map(u => ({
                name: u.name,
                cost: u.cost,
                level: u.level,
                maxLevel: u.maxLevel
            }))
        })),
        // Add isGameOver flag if the game is over
        isGameOver: gameState.currentHealth <= 0
    };
    localStorage.setItem('orbitalDefenseGame_v2.9', JSON.stringify(gameStateData));
    showToast('Game saved!');
}

function tryLoadGame() {
    try {
        const savedData = localStorage.getItem('orbitalDefenseGame_v2.9');
        if (savedData) {
            const parsedData = JSON.parse(savedData);
            // Check if the saved game is a game over state
            if (parsedData.isGameOver) {
                if (DEBUG_MODE) console.log("Saved game data is from a finished game, ignoring.");
                savedGame = null; // Discard finished game save
            } else {
                savedGame = parsedData;
                if (DEBUG_MODE) console.log("Saved game data found:", savedGame);
            }
        } else {
            if (DEBUG_MODE) console.log("No saved game data found.");
            savedGame = null;
        }
    } catch (e) {
        console.error('Error loading saved game:', e);
        savedGame = null;
    }
    // Update visibility of Load and Clear buttons based on save presence
    const display = savedGame ? 'block' : 'none';
    getElement('loadButton').style.display = display;
    getElement('clearSaveButton').style.display = display;
}

function loadGame() {
    if (!savedGame) return false;

    try {
        // Restore game state, base stats
        // Be careful not to overwrite functions or non-serializable data
        Object.assign(gameState, savedGame.gameState);
        // Selectively assign base properties that are saved
        const savedBase = savedGame.base;
        base.x = savedBase.x;
        base.y = savedBase.y;
        base.radius = savedBase.radius;
        base.fireRate = savedBase.fireRate;
        base.bulletDamage = savedBase.bulletDamage;
        base.cannonRange = savedBase.cannonRange;
        base.laserDamage = savedBase.laserDamage;
        base.laserRange = savedBase.laserRange;
        base.laserTargetX = savedBase.laserTargetX;
        base.laserTargetY = savedBase.laserTargetY;
        base.gunBarrelCount = savedBase.gunBarrelCount;
        base.missileCount = savedBase.missileCount;
        base.missileDamage = savedBase.missileDamage;
        base.missileTargetingRadius = savedBase.missileTargetingRadius;
        base.missileExplosionRadius = savedBase.missileExplosionRadius; // Assuming this was saved; if not, recalculate
        base.macrossMissileCount = savedBase.macrossMissileCount;
        base.macrossMissileDamage = savedBase.macrossMissileDamage;
        base.stunLevel = savedBase.stunLevel;
        base.stunRadius = savedBase.stunRadius;
       base.missileSpeedMultiplier = savedBase.missileSpeedMultiplier;
       base.missileTurnSpeed = savedBase.missileTurnSpeed || 0.05;
      base.missileHomingRadius = savedBase.missileHomingRadius;
        base.focusRadiusSetting = savedBase.focusRadiusSetting || 0;
        base.sensorRange = savedBase.sensorRange || base.cannonRange;
        base.missileOrbit = false; // Not implemented?
        base.color = savedBase.color;
        base.currentMoveSpeed = savedBase.currentMoveSpeed; // Restore move speed


        // Restore upgrades levels and costs
        savedGame.upgrades.forEach((savedCategory, i) => {
            savedCategory.upgrades.forEach((savedUpgrade, j) => {
                const currentUpgrade = upgradeTree[i].upgrades[j];
                if (currentUpgrade && currentUpgrade.name === savedUpgrade.name) { // Check name match for safety
                    currentUpgrade.level = savedUpgrade.level;
                    currentUpgrade.cost = savedUpgrade.cost;
                    // Re-apply the effect immediately based on the loaded level
                     applyUpgradeEffect(i, j, false); // Apply without cost/level change
                } else {
                     console.warn(`Upgrade mismatch during load: save='${savedUpgrade.name}', current='${currentUpgrade?.name}'`);
                }
            });
        });

        // Crucially, re-apply all upgrade effects based on the loaded levels
        // (Some might already be applied above, but this ensures consistency)
        // for (let i = 0; i < upgradeTree.length; i++) {
        //     for (let j = 0; j in upgradeTree[i].upgrades.length; j++) {
        //         if (upgradeTree[i].upgrades[j].level > 0) {
        //              applyUpgradeEffect(i, j, false); // false indicates not a new purchase
        //         }
        //     }
        // }


        updateHUD();
        drawGame();
        showToast('Game loaded!');
        return true;
    } catch (e) {
        console.error('Error applying loaded game state:', e);
        // If loading fails, potentially reset to default state
        initializeGame(false); // Re-initialize without trying to load again
        return false;
    }

    // Close loadGame function
}

function clearSavedGame() {
    localStorage.removeItem('orbitalDefenseGame_v2.9');
    localStorage.removeItem('orbitalDefenseTheme_v2.9');
    savedGame = null;
    getElement('loadButton').style.display = 'none';
    getElement('clearSaveButton').style.display = 'none';
    showToast('Save data cleared.');
}

function formatDate(date) {
    const year = date.getFullYear();
    const month = date.toLocaleString('en-US', { month: 'long' });
    const day = date.getDate();
    return `${year} ${month} ${day}`;
}


function cleanDate(value) {
    if (!value) return '';
    if (/^\d{8}$/.test(value)) {
        value = `${value.slice(0,4)}-${value.slice(4,6)}-${value.slice(6)}`;
    }
    try {
        return new Date(value).toISOString().split('T')[0];
    } catch (e) {
        return '';
    }
}







// --- Game Initialization & Start ---
function initializeGame(shouldTryLoad = true) {
    const initialRange = Math.min(canvasWidth, canvasHeight) / 4;

    gameState = {
        credits: 0,
        currentHealth: 100,
        maxHealth: 100,
        wave: 1,
        enemiesSpawnedThisWave: 0,
        lastBulletFireTime: 0,
        isBossWave: false,
        lastDamageTime: 0,
        upgradesAvailable: false, // Flag if any upgrade can be bought
        lastLaserFireTime: 0,
        laserEffectEndTime: 0,
        lastMissileFireTime: 0,
        macrossCooldownTimer: 0,
        stunEffectEndTime: 0, // Not currently used, stun applied directly
        waveStartTime: 0,
        waveElapsedTime: 0,
        waveDuration: WAVE_BASE_DURATION,
        score: 0,
        enemiesKilled: 0,
        autoFire: true,
        doubleFireRateEndTime: 0,
        xpEnemySpawnTime: 0,
        xpEnemySpawned: false
    };

    activeWaves = [1];
    waveBossAlive = { 1: false };

    base = {
        x: canvasWidth / 2,
        y: canvasHeight / 2,
        radius: BASE_RADIUS,
        fireRate: INITIAL_FIRE_RATE, // ms per shot
        bulletDamage: 1,
        cannonRange: initialRange,
        laserDamage: 0, // Needs upgrade
        laserRange: 0, // Needs upgrade
        laserTargetX: 0, laserTargetY: 0, // For visual effect
        manualTargeting: false,
        gunBarrelCount: 1,
        missileCount: 0, // Needs upgrade
        missileDamage: 0,
        missileTargetingRadius: 0,
        missileExplosionRadius: 0, // Not currently implemented?
        macrossMissileCount: 0, // Needs upgrade
        macrossMissileDamage: 20,
        stunLevel: 0, // Needs upgrade
        stunRadius: 0,
        missileSpeedMultiplier: 1,
        missileTurnSpeed: 0.05,
        missileHomingRadius: 0,
        focusRadiusSetting: 0,
        sensorRange: initialRange,
        missileOrbit: false, // Not implemented?
        color: 'rgb(94,79,162)',
        currentMoveSpeed: BASE_INITIAL_MOVE_SPEED // Base speed without upgrades
    };

    sensorUpgrades = { enemyVisuals: false, showHealthBars: false, targetAI: false };
    sensorDisplayMode = 'hud';
    enemyIntel = { active:false, known:{}, order:[] };
    getElement('sensorDisplayToggle').textContent = 'Hud';

    updateEnemyStatsPanel();
    resetPools();
    getElement('macrossButton').classList.remove('active');

    isDragging = false;
    wasDragging = false;
    isReturningToCenter = false;
    lastBaseX = base.x;
    lastBaseY = base.y;


    // --- Upgrade Tree Definition ---
    // f: function to calculate effect based on level
    // g: function to generate display text for the upgrade button
    upgradeTree = [
        { // Category 0: Cannon
            category: "Cannon",
            expanded: false,
            upgrades: [
                { name: 'Fire Rate', cost: 100, level: 0, maxLevel: 15,
                  f: level => 1000 / (5 + level),
                  g: (level, cost, maxLvl) => {
                      const currentRate = 5 + level;
                      const nextRate = level < maxLvl ? currentRate + 1 : currentRate;
                      return `${currentRate}s${level < maxLvl ? ` > ${nextRate}s` : ''}`;
                  }},
                { name: 'Damage', cost: 150, level: 0, maxLevel: 10,
                  f: level => 1 + level, // Damage = 1 + level
                  g: (level, cost, maxLvl) => `${1 + level}${level < maxLvl ? ` > ${2 + level}` : ''}` },
                { name: 'Range', cost: 250, level: 0, maxLevel: 10,
                  f: level => initialRange * Math.pow(1.05, level),
                  g: (level, cost, maxLvl) => `${Math.round(initialRange * Math.pow(1.05, level))}${level < maxLvl ? ` > ${Math.round(initialRange * Math.pow(1.05, level + 1))}` : ''}` },
                { name: 'Guns', cost: 12000, level: 0, maxLevel: 5, // Starts at 1 gun implicitly
                  f: level => level + 1, // Guns = 1 + level
                  g: (level, cost, maxLvl) => `${1 + level}${level < maxLvl ? ` > ${2 + level}` : ''} guns` },
                { name: 'Focus Radius', cost: 500, level: 0, maxLevel: 9, progressBar: true,
                  f: level => level === 0 ? 0 : 0.2 + 0.1 * (level - 1),
                  g: (level, cost, maxLvl) => {
                      const current = level === 0 ? 0 : 20 + (level - 1) * 10;
                      const next = level < maxLvl ? (level === 0 ? 20 : 20 + level * 10) : current;
                      return `${current}%${level < maxLvl ? ` > ${next}%` : ''}`;
                  } }
            ]
        },
        { // Category 1: Defense
            category: "Defense Systems",
            expanded: false,
            upgrades: [
                { name: 'Health', cost: 200, level: 0, maxLevel: 10,
                  f: level => 100 + 50 * level,
                  g: (level, cost, maxLvl) => `${100 + 50 * level}${level < maxLvl ? ` > ${150 + 50 * level}` : ''}` },
                { name: 'Movement', cost: 300, level: 0, maxLevel: 5,
                  f: level => BASE_INITIAL_MOVE_SPEED + level * BASE_MOVE_SPEED_INCREMENT,
                  g: (level, cost, maxLvl) => {
                      const current = BASE_INITIAL_MOVE_SPEED + level * BASE_MOVE_SPEED_INCREMENT;
                      const next = BASE_INITIAL_MOVE_SPEED + (level + 1) * BASE_MOVE_SPEED_INCREMENT;
                      return `${current}${level < maxLvl ? ` > ${next}` : ''}`;
                  } }
            ]
        },
        { // Category 2: Laser
            category: "Laser System",
            expanded: false,
            upgrades: [
                { name: 'Damage', cost: 2000, level: 0, maxLevel: 6,
                  f: level => level === 0 ? 0 : 15 * Math.pow(2, level - 1), // Damage doubles
                  g: (level, cost, maxLvl) => {
                      const currentDmg = level === 0 ? 0 : 15 * Math.pow(2, level - 1);
                      const nextDmg = level < maxLvl ? 15 * Math.pow(2, level) : currentDmg;
                      if (level === 0) return '(Activate)';
                      return `${currentDmg}${level < maxLvl ? ` > ${nextDmg}` : ''}`;
                   }},
                { name: 'Manual Targeting', cost: 2000, level: 0, maxLevel: 1,
                  f: level => level,
                  g: (level) => level > 0 ? 'Enabled' : 'Off' }
            ]
        },
        { // Category 3: Missiles
            category: "Missile Systems",
            expanded: false,
            upgrades: [
                { name: 'Missiles', cost: 2000, level: 0, maxLevel: 6,
                  f: level => level,
                  g: (level, cost, maxLvl) => {
                       if (level === 0) return '(Activate)';
                       const currentCount = level;
                       const nextCount = level < maxLvl ? level + 1 : currentCount;
                       return `${currentCount}${level < maxLvl ? ` > ${nextCount}` : ''}`;
                  }},
                { name: 'Radius', cost: 1500, level: 0, maxLevel: 5, // Requires missile system active
                  f: level => base.cannonRange * (1 + 0.1 * level), // Scales with cannon range
                  g: (level, cost, maxLvl) => `${Math.round(base.cannonRange * (1 + 0.1 * level))}${level < maxLvl ? ` > ${Math.round(base.cannonRange * (1 + 0.1 * (level + 1)))}` : ''}` },
                { name: 'Damage', cost: 2500, level: 0, maxLevel: 5, // Requires missile system active
                  f: level => 10 + 5 * level,
                  g: (level, cost, maxLvl) => `${10 + 5 * level}${level < maxLvl ? ` > ${15 + 5 * level}` : ''}` },
                { name: 'Homing', cost: 3000, level: 0, maxLevel: 5, // Requires missile system active
                  f: level => level === 0 ? 0 : 20 * level,
                  g: (level, cost, maxLvl) => {
                      if (level === 0) return '(Activate)';
                      const currentPct = level * 10;
                      const nextPct = level < maxLvl ? (level + 1) * 10 : currentPct;
                      return `${currentPct}%${level < maxLvl ? ` > ${nextPct}%` : ''}`;
                  }},
                { name: 'Macros', cost: 5000, level: 0, maxLevel: 5,
                  f: level => level === 0 ? 0 : 50 * Math.pow(2, level - 1), // Num missiles 0 -> 50 -> 100 -> ...
                  g: (level, cost, maxLvl) => {
                      if (level === 0) return '(Activate)';
                      const currentCount = 50 * Math.pow(2, level - 1);
                      const nextCount = level < maxLvl ? 50 * Math.pow(2, level) : currentCount;
                      const currentDmg = 20 + level * 5;
                      const nextDmg = level < maxLvl ? 20 + (level + 1) * 5 : currentDmg;
                      const currentCD = MACROSS_BASE_COOLDOWN - level * MACROSS_COOLDOWN_REDUCTION_PER_LEVEL;
                      const nextCD = level < maxLvl ? MACROSS_BASE_COOLDOWN - (level + 1) * MACROSS_COOLDOWN_REDUCTION_PER_LEVEL : currentCD;
                      return `${currentCount}m ${currentDmg}d ${currentCD}s${level < maxLvl ? ` > ${nextCount}m ${nextDmg}d ${nextCD}s` : ''}`;
                   }}
            ]
        },
        { // Category 4: Special
            category: "Special Weapons",
            expanded: false,
            upgrades: [
                { name: 'Stun Field', cost: 2000, level: 0, maxLevel: 9, // Max 90% slow
                  f: level => level * 0.1, // Returns the slow factor (0 to 0.9)
                  g: (level, cost, maxLvl) => `${level * 10}%${level < maxLvl ? `>${(level + 1) * 10}%` : ''}` }
            ]
        },
        { // Category 5: Sensors
            category: "Sensors",
            expanded: false,
            upgrades: [
                { name: 'Electronic FOV', cost: 50, level: 0, maxLevel: 20,
                  f: level => 1 + 0.1 * level,
                  g: (level, cost, maxLvl) => {
                      const current = Math.round((1 + 0.1 * level) * 100);
                      const next = Math.round((1 + 0.1 * (level + 1)) * 100);
                      return `${current}%${level < maxLvl ? ` > ${next}%` : ''}`;
                  } },
                { name: 'Enemy Identification', cost: 100, level: 0, maxLevel: 1,
                  f: level => level > 0,
                  g: (level) => level > 0 ? 'On' : '(Enable)' },
                { name: 'Calculate Enemies\u2019 Health', cost: 500, level: 0, maxLevel: 1,
                  f: level => level > 0,
                  g: (level) => level > 0 ? 'On' : '(Enable)' },
                { name: 'Target Analysis AI', cost: 3000, level: 0, maxLevel: 1,
                  f: level => level > 0,
                  g: (level) => level > 0 ? 'Active' : '(Install)' }
            ]
        },
        { // Category 6: Debug
            category: "Debug",
            expanded: false,
            upgrades: [
                {
                    name: '+100,000 credits',
                    cost: 0,
                    level: 0,
                    maxLevel: Infinity,
                    f: () => {},
                    g: () => ''
                }
            ]
        }
    ];

    updateHUD();
    drawGame();

    if (shouldTryLoad) {
        tryLoadGame(); // Check for saved game after defaults are set
    }
}

function startGame() {
    window.pendingScore = null;
    unlistenLeaderboard();
    initializeGame(true); // Initialize with saved game check
    getElement('startScreen').style.display = 'none';
    getElement('leaderboard-screen').style.display = 'none';
    getElement('gameOverScreen').style.display = 'none';
    getElement('deathOverlay').style.display = 'none';
    getElement('initialsInput').value = '';
    pauseGame(); // Ensure no game loop is running
    gameSpeedMultiplier = 1;
    speedIndex = SPEED_STEPS.indexOf(1);
    updateSpeedDisplay();
    getElement('playPauseButton').textContent = '\u25B6'; // Show play icon while paused
    drawGame();
    updateHUD();
    showSensorWarning();
}

function startDeathSequence() {
    if (!isDeathSequence) {
        isDeathSequence = true;
        deathSequenceStartTime = Date.now();
    }
}

function gameOver() {
    isGameRunning = 0;
    isDeathSequence = false;
    deathSequenceStartTime = 0;
    cancelAnimationFrame(animationFrameId);
    if (autoSaveTimer) clearInterval(autoSaveTimer);
    gameSpeedMultiplier = 1;
    speedIndex = SPEED_STEPS.indexOf(1);
    updateSpeedDisplay();
    getElement('playPauseButton').textContent = '\u25B6';
    getElement('gameOverScreen').style.display = 'flex';
    getElement('deathOverlay').style.display = 'block';
    const survivalTime = Math.floor((Date.now() - gameStartTime) / 1000);
    getElement('finalStats').textContent = `Wave ${gameState.wave}/${survivalTime}s - ${formatDate(new Date())}`;
    const remainingTime = Math.floor(Math.max(0, gameState.waveDuration - gameState.waveElapsedTime));
    const playerRank = gameState.wave * 100000 - remainingTime;
    window.pendingScore = { wave: gameState.wave, time: remainingTime, ranking: playerRank, saved: false };
    getTopScores().then(scores => {
        let index = scores.findIndex(s => playerRank > s.ranking);
        if (index === -1 && scores.length < 10) index = scores.length;
        let list = scores.slice();
        if (index !== -1) {
            list.splice(index, 0, { initials: '???', wave: gameState.wave, time: remainingTime, date: formatDate(new Date()) });
            list = list.slice(0, 10);
        }
        renderScoreList('gameOverScoreList', list, index);
        const qualifies = index !== -1;
        if (qualifies) {
            getElement('initialsInput').style.display = 'block';
            getElement('cheekyMessage').textContent = 'Hey, you scored in the top 10! Please enter your initials.';
            getElement('initialsInput').focus();
        } else {
            const phrases = [
                'So close, yet orbital debris…',
                'Your score called. It wants another chance.',
                'Your gran could’ve done better… but we believe in you.',
                'Launch again, recruit.',
                'Good news: you’re in the Top 1000!',
                'Now serving humble pie.',
                'Failure builds character. Try again?',
                'Almost made it. Like, just almost.',
                'Mission: failed. Style: impeccable.',
                'It’s not about the score. It’s about the… no wait, it is about the score.'
            ];
            getElement('initialsInput').style.display = 'none';
            getElement('cheekyMessage').textContent = phrases[Math.floor(Math.random()*phrases.length)];
            window.pendingScore.saved = true; // No need to save if not top 10
        }
    });
    saveGame(); // Save final state on game over
}

// --- Main Game Loop ---
function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    deltaTime = Math.min(0.1, (timestamp - lastTime) / 1000); // Delta time in seconds, capped to prevent large jumps
    lastTime = timestamp;

    if (isGameRunning) {
        if (isDeathSequence) {
            gameSpeedMultiplier = 0.2;
        }

        updateGame(deltaTime); // Update game state
        drawGame(); // Draw game elements
        updateHUD(); // Update UI text

        if (isDeathSequence) {
            if (Date.now() - deathSequenceStartTime >= 1500) {
                gameOver();
            } else {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        } else if (gameState.currentHealth > 0) {
            animationFrameId = requestAnimationFrame(gameLoop);
        } else {
            startDeathSequence();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }
}

// --- Game Update Logic ---
function updateGame(dt) {
    // Apply game speed multiplier to delta time
    const effectiveDt = dt * gameSpeedMultiplier;

    // Countdown target lock timers
    enemyPool.getActiveObjects().forEach(e => {
        e.targetLockTime = Math.max(0, (e.targetLockTime || 0) - effectiveDt * 1000);
        e.isTargeted = e.targetLockTime > 0;
    });

    handleBaseMovement(effectiveDt);
    const baseMoved = updateEnemies(effectiveDt); // Returns true if base drag/return caused global move
    spawnNewEnemies(effectiveDt);
    handlePlayerFiring(effectiveDt);
    updateProjectiles(effectiveDt, baseMoved); // Pass baseMoved to adjust projectile trails if needed
    checkCollisions(effectiveDt);
    updateParticles(effectiveDt);
    updateCooldowns(effectiveDt);
    checkWaveCompletion(effectiveDt);
    updateUpgradeAvailabilityFlags();
}

function handleBaseMovement(dt) {
    if (!baseCanMove) return;

    const dtScaled = dt * 60;
    const prevBaseX = base.x;
    const prevBaseY = base.y;

    if (isReturningToCenter && !isDragging) {
        const timeSinceReturn = (Date.now() - centerReturnStartTime) / 1000;
        const progress = Math.min(1, timeSinceReturn / 3);
        const easeFactor = 1 - Math.pow(1 - progress, 3); // Cubic ease-out

        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;
        const dx = centerX - base.x;
        const dy = centerY - base.y;
        const dist = Math.hypot(dx, dy);

        if (dist > 1) {
            const moveAmount = centerReturnSpeed * easeFactor * dtScaled;
            base.x += (dx / dist) * moveAmount;
            base.y += (dy / dist) * moveAmount;
            base.x = Math.max(base.radius, Math.min(canvasWidth - base.radius, base.x));
            base.y = Math.max(base.radius, Math.min(canvasHeight - base.radius, base.y));
        } else {
            isReturningToCenter = false;
        }
    } else if (!isDragging) {
        // Keyboard movement
        const moveSpeed = base.currentMoveSpeed * dtScaled;
        let dx = 0, dy = 0;
        if (keysPressed['ArrowUp'] || keysPressed['w'] || keysPressed['W']) dy -= 1;
        if (keysPressed['ArrowDown'] || keysPressed['s'] || keysPressed['S']) dy += 1;
        if (keysPressed['ArrowLeft'] || keysPressed['a'] || keysPressed['A']) dx -= 1;
        if (keysPressed['ArrowRight'] || keysPressed['d'] || keysPressed['D']) dx += 1;

        const len = Math.hypot(dx, dy);
        if (len > 0) {
            dx = (dx / len) * moveSpeed;
            dy = (dy / len) * moveSpeed;
            base.x = Math.max(base.radius, Math.min(canvasWidth - base.radius, base.x + dx));
            base.y = Math.max(base.radius, Math.min(canvasHeight - base.radius, base.y + dy));
        }
    }
     // else: Movement handled by drag handlers

}

function updateEnemies(dt) {
    const enemies = enemyPool.getActiveObjects();
    let baseMovedDuringUpdate = false;

    const dtScaled = dt * 60;
    // Check if base moved since last frame
    const deltaX = base.x - lastBaseX;
    const deltaY = base.y - lastBaseY;
    if (deltaX !== 0 || deltaY !== 0) {
        baseMovedDuringUpdate = true;
        // Shift enemies to keep world position consistent
        enemies.forEach(enemy => {
            enemy.x -= deltaX;
            enemy.y -= deltaY;
            enemy.trail = enemy.trail.map(p => ({ x: p.x - deltaX, y: p.y - deltaY }));
        });
    }
    lastBaseX = base.x;
    lastBaseY = base.y;

    let closest = null;
    let closestDist = Infinity;
    const detectionRange = Math.max(base.cannonRange, base.missileTargetingRadius, base.laserRange, base.sensorRange, base.stunRadius);
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const distToBase = Math.hypot(base.x - enemy.x, base.y - enemy.y);

        if (enemy.xp) {
            enemy.x += enemy.dir * enemy.speed * dtScaled;
            if (enemy.x > base.x + canvasWidth / 2 - enemy.radius || enemy.x < base.x - canvasWidth / 2 + enemy.radius) {
                enemy.dir *= -1;
            }
            continue; // Skip normal behaviour
        }

        // Apply stun field effect
        if (base.stunLevel > 0 && distToBase <= base.stunRadius && !enemy.isStunned) {
            enemy.isStunned = true;
            enemy.stunTime = Date.now();
            createParticle(enemy.x, enemy.y, currentTheme.canvasColors.particleStun, 2, 0.5, 3); // Stun visual
        }

        // Update stun status and speed
        let currentSpeed = enemy.normalSpeed;
        if (enemy.isStunned) {
            if (Date.now() - enemy.stunTime > STUN_EFFECT_DURATION) {
                enemy.isStunned = false;
            } else {
                currentSpeed *= (1 - base.stunLevel * 0.1); // Reduce speed based on stun upgrade level
            }
        }
        enemy.speed = currentSpeed; // Update speed property used for movement

        // Move enemy towards base
        if (distToBase > 0) { // Avoid division by zero if somehow enemy is exactly at base center
             const angle = Math.atan2(base.y - enemy.y, base.x - enemy.x);
             enemy.x += Math.cos(angle) * enemy.speed * dtScaled;
             enemy.y += Math.sin(angle) * enemy.speed * dtScaled;
        }


        // Update trail for fast enemies
        if (sensorUpgrades.enemyVisuals) {
            if (enemy.speed > 3) { // Threshold for trailing effect
                enemy.trail.unshift({ x: enemy.x, y: enemy.y });
                if (enemy.trail.length > 5) enemy.trail.pop();
            } else {
                enemy.trail = [];
            }
        } else {
            enemy.trail = [];
        }

        // Mark candidate for enemy identification
        if(enemyIntel.active && !enemyIntel.known[enemy.type] && distToBase <= detectionRange && distToBase < closestDist){
            closest = enemy;
            closestDist = distToBase;
        }

        // Check collision with base
        if (distToBase < base.radius + enemy.radius) {
            gameState.currentHealth -= enemy.type === 'Fast' ? Math.ceil(gameState.maxHealth * 0.25) : enemy.radius; // Fast enemies do % damage
            gameState.lastDamageTime = Date.now();
            createExplosion(enemy.x, enemy.y, enemy.color, 20, enemy.radius);
            updateHUD(); // Update health display immediately
            enemyPool.release(enemy);
            handleEnemyKilled(enemy);
            if (gameState.currentHealth <= 0) {
                 startDeathSequence(); // Begin slow-motion before game over
                 return baseMovedDuringUpdate; // Exit early
            }
            continue; // Skip rest of loop for this enemy
        }
    }

    if(closest) identifyEnemy(closest);
    return baseMovedDuringUpdate;
}


function spawnNewEnemies(dt) {
    gameState.waveElapsedTime += dt;
    const elapsedTime = gameState.waveElapsedTime;
    const enemies = enemyPool.getActiveObjects();
    const dtScaled = dt * 60;

    if (!gameState.xpEnemySpawned && elapsedTime >= gameState.xpEnemySpawnTime) {
        spawnXPEnemy();
        gameState.xpEnemySpawned = true;
        if (!xpCardShown) {
            showToast('XP Enemy spotted! Use Manual Laser to destroy.', 4000);
            xpCardShown = true;
        }
    }

    // Boss spawning
    if (!gameState.isBossWave && elapsedTime >= gameState.waveDuration) {
        spawnEnemy(true); // Spawn the boss
        gameState.isBossWave = true;
        showToast('Boss Wave!', 3000);
    }
    // Regular enemy spawning (if not boss wave and below limit)
    else if (!gameState.isBossWave && enemies.length < MAX_ENEMY_COUNT && Math.random() < 0.03 * gameSpeedMultiplier * dtScaled) { // Slightly increased spawn rate
        spawnEnemy(false);
    }
}

function handlePlayerFiring(dt) {
    const currentTime = Date.now();
    const enemies = enemyPool.getActiveObjects();

    // --- Bullet Firing ---
    const rate = base.fireRate / (currentTime < gameState.doubleFireRateEndTime ? 2 : 1);
    if (currentTime - gameState.lastBulletFireTime >= rate / gameSpeedMultiplier) {
        // Find nearest enemy within cannon range
        let nearestEnemy = null;
        let minDistanceSq = base.cannonRange * base.cannonRange;

        enemies.forEach(enemy => {
            const dx = enemy.x - base.x;
            const dy = enemy.y - base.y;
            const distSq = dx * dx + dy * dy;
            if (distSq <= minDistanceSq) {
                minDistanceSq = distSq;
                nearestEnemy = enemy;
            }
        });

        if (nearestEnemy && (gameState.autoFire || keysPressed[' '])) {
            let targets = enemies
                .filter(e => Math.hypot(e.x - base.x, e.y - base.y) <= base.cannonRange)
                .filter(e => !sensorUpgrades.targetAI || (e.health - (e.allocatedDamage||0) > 0))
                .sort((a, b) => Math.hypot(a.x - base.x, a.y - base.y) - Math.hypot(b.x - base.x, b.y - base.y));
            const bigThreat = targets.find(e => e.radius >= 20 && Math.hypot(e.x - base.x, e.y - base.y) <= base.cannonRange * 0.5);
            const focusTarget = targets.find(e => Math.hypot(e.x - base.x, e.y - base.y) <= base.cannonRange * base.focusRadiusSetting);
            if (bigThreat) {
                targets = Array(base.gunBarrelCount).fill(bigThreat);
            } else if (focusTarget) {
                targets = Array(base.gunBarrelCount).fill(focusTarget);
            } else {
                if (targets.length < base.gunBarrelCount) {
                    while (targets.length < base.gunBarrelCount) targets.push(nearestEnemy);
                } else {
                    targets = targets.slice(0, base.gunBarrelCount);
                }
            }

            for (let i = 0; i < base.gunBarrelCount; i++) {
                const t = targets[i] || nearestEnemy;
                if (t) {
                    t.isTargeted = true;
                    t.targetLockTime = TARGET_LOCK_DURATION;
                }
                const angle = Math.atan2(t.y - base.y, t.x - base.x);
                const shade = Math.floor((i - (base.gunBarrelCount - 1) / 2) * 20);
                bulletPool.get({
                    x: base.x,
                    y: base.y,
                    dx: Math.cos(angle),
                    dy: Math.sin(angle),
                    color: shadeColor(currentTheme.canvasColors.bullet, shade)
                });
                if (sensorUpgrades.targetAI) t.allocatedDamage = (t.allocatedDamage||0) + base.bulletDamage;
            }
            gameState.lastBulletFireTime = currentTime;
        }
    }

    // --- Missile Firing ---
    if (base.missileCount > 0 && currentTime - gameState.lastMissileFireTime >= MISSILE_FIRE_INTERVAL / gameSpeedMultiplier) {
        let targets = enemies
            .filter(enemy => Math.hypot(enemy.x - base.x, enemy.y - base.y) <= base.missileTargetingRadius)
            .filter(e => !sensorUpgrades.targetAI || (e.health - (e.allocatedDamage||0) > 0))
            .sort((a, b) => Math.hypot(a.x - base.x, a.y - base.y) - Math.hypot(b.x - base.x, b.y - base.y))
            .slice(0, base.missileCount); // Fire up to missileCount missiles

        if (targets.length > 0) {
             targets.forEach(target => {
                target.isTargeted = true;
                target.targetLockTime = TARGET_LOCK_DURATION;
                const angle = Math.atan2(target.y - base.y, target.x - base.x);
                const launchAngle = angle + (Math.random() - 0.5) * (Math.PI / 8); // Launch spread

                missilePool.get({
                    x: base.x,
                    y: base.y,
                    dx: Math.cos(launchAngle),
                    dy: Math.sin(launchAngle),
                    t: target,
                    speed: 2 + Math.random() * 2,
                    turnSpeed: base.missileTurnSpeed,
                    homingRadius: base.missileHomingRadius,
                    homingActive: true,
                    startX: base.x,
                    startY: base.y,
                    rangeLimit: base.missileTargetingRadius * 1.1
                });
                if (sensorUpgrades.targetAI) target.allocatedDamage = (target.allocatedDamage||0) + base.missileDamage;
             });
            createExplosion(base.x, base.y, 'orange', 5 * targets.length, 8); // Bigger launch effect for more missiles
            gameState.lastMissileFireTime = currentTime;
        }
    }

    // --- Laser Firing ---
    if (base.laserDamage > 0 && currentTime - gameState.lastLaserFireTime >= LASER_FIRE_INTERVAL / gameSpeedMultiplier) {
        // Target Fast or Boss enemies first within laser range
        const laserTarget = enemies.find(enemy =>
            !enemy.xp && (enemy.type === 'Fast' || enemy.type === 'Boss') &&
            Math.hypot(enemy.x - base.x, enemy.y - base.y) <= base.laserRange &&
            (!sensorUpgrades.targetAI || (enemy.health - (enemy.allocatedDamage||0) > 0))
        );

        if (laserTarget) {
            laserTarget.isTargeted = true;
            laserTarget.targetLockTime = TARGET_LOCK_DURATION;
            laserTarget.health -= base.laserDamage;
            gameState.lastLaserFireTime = currentTime;
            gameState.laserEffectEndTime = currentTime + 200; // Duration of visual effect
            base.laserTargetX = laserTarget.x;
            base.laserTargetY = laserTarget.y;

            // Laser hit particles
            for (let i = 0; i < 5; i++) {
                const t = i / 5;
                createParticle(
                    base.x + (laserTarget.x - base.x) * t,
                    base.y + (laserTarget.y - base.y) * t,
                    currentTheme.canvasColors.laser, 1, 0.2, 3 // Use laser color for particles
                );
            }

             // Check if laser killed the enemy
             if (laserTarget.health <= 0) {
                 gameState.credits += laserTarget.creditsValue;
                 gameState.score += laserTarget.creditsValue * 20; // More points for laser kills
                 gameState.enemiesKilled++;
                 createExplosion(laserTarget.x, laserTarget.y, laserTarget.color, 40, laserTarget.radius);
                 enemyPool.release(laserTarget);
                 handleEnemyKilled(laserTarget);
                 updateUpgradeAvailabilityFlags();
             }
        }
    }
}

function updateProjectiles(dt, baseMoved) {
    const bullets = bulletPool.getActiveObjects();
    const missiles = missilePool.getActiveObjects();
    const enemies = enemyPool.getActiveObjects(); // Need enemy list for missile targeting
    const dtScaled = dt * 60;

    // --- Update Bullets ---
    const bulletMoveDist = BULLET_BASE_SPEED * dtScaled;
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        bullet.x += bullet.dx * bulletMoveDist;
        bullet.y += bullet.dy * bulletMoveDist;

        // Remove bullets out of bounds
        if (bullet.x < -10 || bullet.x > canvasWidth + 10 || bullet.y < -10 || bullet.y > canvasHeight + 10) {
            bulletPool.release(bullet);
        }
        // Collision checked in checkCollisions
    }

    // --- Update Missiles ---
    const missileBaseSpeed = 2; // Base speed units per update cycle (before multipliers)
    const missileTurnSpeed = base.missileTurnSpeed;

    for (let i = missiles.length - 1; i >= 0; i--) {
        const missile = missiles[i];
        let targetEnemy = missile.target;

        // 1. Homing Logic: Find/Update Target
        if (targetEnemy && !enemies.includes(targetEnemy)) {
            targetEnemy = null; // Target destroyed or released
            missile.target = null;
            missile.homingActive = true; // Activate general homing
        }

        if (!targetEnemy && missile.homingActive) {
            // Find the closest enemy within homing range
            let closestDistSq = (missile.homingRadius || base.missileHomingRadius) ** 2;
            let potentialTarget = null;
            enemies.forEach(enemy => {
                const dx = enemy.x - missile.x;
                const dy = enemy.y - missile.y;
                const distSq = dx * dx + dy * dy;
                if (distSq < closestDistSq) {
                    closestDistSq = distSq;
                    potentialTarget = enemy;
                }
            });
            targetEnemy = potentialTarget;
            missile.target = targetEnemy; // Update target for next frame
            if (targetEnemy) {
                missile.speed *= 1 + upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_HOMING].level * 0.05;
            }
        }

        // 2. Steering Logic
        if (targetEnemy) {
            targetEnemy.isTargeted = true;
            targetEnemy.targetLockTime = TARGET_LOCK_DURATION;
            const dx = targetEnemy.x - missile.x;
            const dy = targetEnemy.y - missile.y;
            const targetAngle = Math.atan2(dy, dx);
            const currentAngle = Math.atan2(missile.dy, missile.dx);

            let angleDiff = targetAngle - currentAngle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

            // Limit turning rate
            const turnAmount = Math.max(-missileTurnSpeed, Math.min(missileTurnSpeed, angleDiff));
            const newAngle = currentAngle + turnAmount;

            missile.dx = Math.cos(newAngle);
            missile.dy = Math.sin(newAngle);
        }
        // else: continue straight

        // 3. Movement
        const missileMoveDist = missile.speed * base.missileSpeedMultiplier * dtScaled;
        missile.x += missile.dx * missileMoveDist;
        missile.y += missile.dy * missileMoveDist;

        // 4. Update Trail
        missile.trail.unshift({ x: missile.x, y: missile.y });
        if (missile.trail.length > 40) missile.trail.pop();

        // 5. Check bounds / Range (collision checked separately)
        const distFromStart = Math.hypot(missile.x - missile.startX, missile.y - missile.startY);
        if (distFromStart > missile.rangeLimit ||
            missile.x < -50 || missile.x > canvasWidth + 50 ||
            missile.y < -50 || missile.y > canvasHeight + 50) {
            missilePool.release(missile);
        }
    }
}

function checkCollisions(dt) {
    const enemies = enemyPool.getActiveObjects();
    const bullets = bulletPool.getActiveObjects();
    const missiles = missilePool.getActiveObjects();

    // --- Bullet-Enemy Collisions ---
    for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        let bulletHit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            if (enemy.xp) continue;
            if (enemy.xp) continue;
            // Simple circle collision check
            const dx = bullet.x - enemy.x;
            const dy = bullet.y - enemy.y;
            const distSq = dx*dx + dy*dy;
            const radiiSumSq = (enemy.radius + 3) * (enemy.radius + 3); // 3 is bullet radius approx

            if (distSq < radiiSumSq) {
                bulletHit = true;
                enemy.health -= base.bulletDamage;
                if (sensorUpgrades.targetAI) enemy.allocatedDamage = Math.max(0, (enemy.allocatedDamage||0) - base.bulletDamage);
                createParticle(bullet.x, bullet.y, currentTheme.canvasColors.particleHit, 2, 0.3, 2); // Hit spark

                if (enemy.health <= 0) {
                    gameState.credits += enemy.creditsValue;
                    gameState.score += enemy.creditsValue * 10;
                    gameState.enemiesKilled++;
                    createExplosion(enemy.x, enemy.y, enemy.color, 30, enemy.radius);
                    enemyPool.release(enemy); // Remove enemy
                    handleEnemyKilled(enemy);
                    updateUpgradeAvailabilityFlags();
                }
                break; // Bullet hits one enemy max
            }
        }
        if (bulletHit) {
            bulletPool.release(bullet); // Remove bullet
        }
    }

    // --- Missile-Enemy Collisions ---
    for (let i = missiles.length - 1; i >= 0; i--) {
        const missile = missiles[i];
        let missileHit = false;
        for (let j = enemies.length - 1; j >= 0; j--) {
            const enemy = enemies[j];
            const dx = missile.x - enemy.x;
            const dy = missile.y - enemy.y;
            const distSq = dx * dx + dy * dy;
            const radiiSumSq = (enemy.radius + 5) * (enemy.radius + 5); // Missile collision radius approx 5

            if (distSq < radiiSumSq) {
                missileHit = true;
                const damage = missile.isMacross ? base.macrossMissileDamage : base.missileDamage;
                enemy.health -= damage;
                if (sensorUpgrades.targetAI) enemy.allocatedDamage = Math.max(0, (enemy.allocatedDamage||0) - damage);
                 // Small impact explosion
                 createExplosion(missile.x, missile.y, currentTheme.canvasColors.missile, 10, enemy.radius / 2); // Use missile color

                if (enemy.health <= 0) {
                    gameState.credits += enemy.creditsValue;
                    gameState.score += enemy.creditsValue * 15; // More points for missile kills
                    gameState.enemiesKilled++;
                    createExplosion(enemy.x, enemy.y, enemy.color, 35, enemy.radius); // Bigger death explosion
                    enemyPool.release(enemy);
                    handleEnemyKilled(enemy);
                    updateUpgradeAvailabilityFlags();
                }
                 // Missile only hits one enemy, but doesn't necessarily get destroyed?
                 // For now, let's destroy it on hit. Could add piercing later.
                break;
            }
        }
         if (missileHit) {
             missilePool.release(missile); // Remove missile
         }
    }
}


function updateCooldowns(dt) {
    // Macross Missile Cooldown
    if (gameState.macrossCooldownTimer > 0) {
        gameState.macrossCooldownTimer -= dt;
        if (gameState.macrossCooldownTimer <= 0) {
            gameState.macrossCooldownTimer = 0;
             if(base.macrossMissileCount > 0) { // Only enable if upgrade purchased
                 getElement('macrossButton').disabled = false;
                 getElement('macrossButton').classList.add('active');
             }
        }
    }
}

function startNextWave() {
    gameState.wave++;
    gameState.enemiesSpawnedThisWave = 0;
    gameState.isBossWave = false;
    gameState.currentHealth = Math.min(gameState.maxHealth, gameState.currentHealth + Math.floor(gameState.maxHealth * 0.1));
    gameState.waveDuration = WAVE_BASE_DURATION + (gameState.wave - 1) * WAVE_DURATION_INCREMENT;
    gameState.waveStartTime = Date.now();
    gameState.waveElapsedTime = 0;
    gameState.xpEnemySpawned = false;
    gameState.xpEnemySpawnTime = Math.random() * (gameState.waveDuration - 2);
    activeWaves.push(gameState.wave);
    waveBossAlive[gameState.wave] = false;
    showToast(`Wave ${gameState.wave} started! +10% Health`, 3000);
    updateHUD();
    saveGame();
}

function checkWaveCompletion(dt) {
    const enemies = enemyPool.getActiveObjects();
    // Remove finished waves from display but keep current wave even if empty
    activeWaves = activeWaves.filter(w =>
        w === gameState.wave || waveBossAlive[w] || enemies.some(e => e.wave === w)
    );
    // If all spawned enemies have been cleared, start the next wave
    // but only after at least one enemy was actually spawned in this wave
    if (enemies.length === 0 && gameState.enemiesSpawnedThisWave > 0) {
        startNextWave();
    }
}

function updateUpgradeAvailabilityFlags() {
    // Check if any upgrade is affordable, ignoring hidden debug category
    gameState.upgradesAvailable = upgradeTree.some((category, idx) => {
        if (idx === UPGRADE_CATEGORY_DEBUG && !debugUpgradesVisible) return false;
        return category.upgrades.some(u => gameState.credits >= u.cost && u.level < u.maxLevel);
    });
    // Base color change removed, could be added back if desired
}


// --- Drawing Logic ---
function drawGame() {
    // Clear canvas (using theme color)
    ctx.fillStyle = currentTheme.cssVariables['--canvas-bg'] || 'rgba(0, 0, 0, 0.3)'; // Use theme canvas bg or default
    ctx.fillRect(0, 0, canvasWidth, canvasHeight);

    // --- Draw Range Rings ---
    ctx.lineWidth = 2;
    // Cannon Range
    const canUpgradeCannonRange = gameState.credits >= upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_RANGE].cost && upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_RANGE].level < upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_RANGE].maxLevel;
    ctx.strokeStyle = canUpgradeCannonRange ? currentTheme.canvasColors.ringCannonUpgrade : currentTheme.canvasColors.ringCannon;
    ctx.beginPath();
    ctx.arc(base.x, base.y, base.cannonRange, 0, Math.PI * 2);
    ctx.stroke();

    // Missile Range (if applicable)
    if (base.missileCount > 0 && base.missileTargetingRadius > 0) {
        const canUpgradeMissileRange = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_COUNT].level > 0 && gameState.credits >= upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_RANGE].cost && upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_RANGE].level < upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_RANGE].maxLevel;
        ctx.strokeStyle = canUpgradeMissileRange ? currentTheme.canvasColors.ringMissileUpgrade : currentTheme.canvasColors.ringMissile;
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.missileTargetingRadius, 0, Math.PI * 2);
        ctx.stroke();
    }
    // Laser Range (if applicable)
    if (base.laserDamage > 0 && base.laserRange > 0) {
        const canUpgradeLaser = gameState.credits >= upgradeTree[UPGRADE_CATEGORY_LASER].upgrades[UPGRADE_LASER_DAMAGE].cost && upgradeTree[UPGRADE_CATEGORY_LASER].upgrades[UPGRADE_LASER_DAMAGE].level < upgradeTree[UPGRADE_CATEGORY_LASER].upgrades[UPGRADE_LASER_DAMAGE].maxLevel;
        ctx.strokeStyle = canUpgradeLaser ? currentTheme.canvasColors.ringLaserUpgrade : currentTheme.canvasColors.ringLaser;
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.laserRange, 0, Math.PI * 2);
        ctx.stroke();
    }
    // Stun Range (if applicable)
    if (base.stunLevel > 0 && base.stunRadius > 0) {
        const canUpgradeStun = gameState.credits >= upgradeTree[UPGRADE_CATEGORY_SPECIAL].upgrades[UPGRADE_SPECIAL_STUN].cost && upgradeTree[UPGRADE_CATEGORY_SPECIAL].upgrades[UPGRADE_SPECIAL_STUN].level < upgradeTree[UPGRADE_CATEGORY_SPECIAL].upgrades[UPGRADE_SPECIAL_STUN].maxLevel;
        ctx.strokeStyle = canUpgradeStun ? currentTheme.canvasColors.ringStunUpgrade : currentTheme.canvasColors.ringStun;
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.stunRadius, 0, Math.PI * 2);
        ctx.stroke();
    }
    if (base.focusRadiusSetting > 0) {
        ctx.strokeStyle = colorWithAlpha(currentTheme.canvasColors.ringCannon, 0.2);
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.cannonRange * base.focusRadiusSetting, 0, Math.PI * 2);
        ctx.stroke();
    }
    if (base.sensorRange > base.cannonRange) {
        ctx.strokeStyle = colorWithAlpha(currentTheme.canvasColors.ringSensor, 0.15);
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.sensorRange, 0, Math.PI * 2);
        ctx.stroke();
    }

    // --- Draw Ring UI (Directly on Canvas) ---
    ringClickRegions = []; // Clear regions each frame

    // --- Draw Collapsible Upgrade Categories ---
    const menuX = 10;
    let currentY = 60;
    const categorySpacing = 10;

    upgradeTree.forEach((category, i) => {
        if (i === UPGRADE_CATEGORY_DEBUG && !debugUpgradesVisible) return;
        const color = getCategoryColor(i);
        const hasAvailable = category.upgrades.some(u => gameState.credits >= u.cost && u.level < u.maxLevel);
        const h = drawCollapsibleUpgradeElement(menuX, currentY, category.category, category, i, category.expanded, color, hasAvailable);
        currentY += h + categorySpacing;
    });


    // --- Draw Base ---
    const baseHitTime = 200;
    const flashColor = currentTheme.canvasColors.baseHit;
    const baseColor = (Date.now() - gameState.lastDamageTime < baseHitTime) ? flashColor : currentTheme.canvasColors.base;
    ctx.fillStyle = baseColor;
    ctx.strokeStyle = baseColor; // Use fill color for stroke too
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(base.x, base.y, base.radius, 0, Math.PI * 2);
    ctx.fill();
    // Optional: Add a subtle border (maybe theme dependent?)
    // ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    // ctx.stroke();


    // --- Draw Base State Indicators ---
    if (isDragging) {
        ctx.strokeStyle = currentTheme.canvasColors.baseDragIndicator;
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.radius + 8, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    } else if (isReturningToCenter) {
        ctx.strokeStyle = currentTheme.canvasColors.baseReturnIndicator;
        ctx.setLineDash([3, 3]);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(base.x, base.y, base.radius + 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // --- Draw Upgrade Rings (Visual only now) ---
    const laserLevel = upgradeTree[UPGRADE_CATEGORY_LASER].upgrades[UPGRADE_LASER_DAMAGE].level;
    const missileLevel = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_COUNT].level;
    const maxRings = Math.max(laserLevel, missileLevel);
    ctx.lineWidth = 2;
    for (let i = 0; i < maxRings; i++) {
        const ringRadius = base.radius + 5 + i * 6; // Slightly adjusted spacing
        if (i < laserLevel) {
            ctx.strokeStyle = currentTheme.canvasColors.upgradeRingLaser;
            ctx.beginPath();
            ctx.arc(base.x, base.y, ringRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
        if (i < missileLevel) {
            ctx.strokeStyle = currentTheme.canvasColors.upgradeRingMissile;
            ctx.beginPath();
            ctx.arc(base.x, base.y, ringRadius + 2, 0, Math.PI * 2); // Offset slightly
            ctx.stroke();
        }
    }


    // --- Draw Gun Barrel Indicator ---
    const enemies = enemyPool.getActiveObjects();
    let nearestEnemy = null;
    let minDistanceSq = Infinity;
    enemies.forEach(enemy => {
        const dx = enemy.x - base.x;
        const dy = enemy.y - base.y;
        const distSq = dx * dx + dy * dy;
        if (distSq < minDistanceSq) {
            minDistanceSq = distSq;
            nearestEnemy = enemy;
        }
    });

    if (nearestEnemy) {
        const gunAngle = Math.atan2(nearestEnemy.y - base.y, nearestEnemy.x - base.x);
        ctx.save();
        ctx.translate(base.x, base.y);
        ctx.rotate(gunAngle);
        ctx.fillStyle = currentTheme.canvasColors.gunBarrel;
        // Draw concentric circles for barrels
        for (let i = 0; i < base.gunBarrelCount; i++) {
            ctx.beginPath();
            ctx.arc(base.radius * 0.5 + i * 3, 0, 3 - i * 0.5, 0, Math.PI * 2); // Barrels pointing out
            ctx.fill();
        }
        ctx.restore();
    }


    // --- Draw Enemies ---
    ctx.lineWidth = 2;
    const hudInfo = {};
    enemies.forEach(enemy => {
        if (Math.hypot(enemy.x - base.x, enemy.y - base.y) > base.sensorRange) return;
        const bracketSize = sensorUpgrades.enemyVisuals ? enemy.radius + 4 : 8;
        const showBracket = sensorDisplayMode !== 'off' || enemy.isTargeted;
        if (showBracket) {
            const color = enemy.isTargeted ? '#ff0000' : '#ffcc00';
            drawBracket(enemy.x, enemy.y, bracketSize, color, !enemy.isTargeted);
        }

        if (sensorUpgrades.enemyVisuals) {
            if (enemy.trail.length > 1) {
                ctx.strokeStyle = `${enemy.color}80`;
                ctx.beginPath();
                ctx.moveTo(enemy.trail[0].x, enemy.trail[0].y);
                for(let i = 1; i < enemy.trail.length; i++) {
                    ctx.globalAlpha = 1 - (i / enemy.trail.length) * 0.7;
                    ctx.lineTo(enemy.trail[i].x, enemy.trail[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
            }

            ctx.fillStyle = enemy.color;
            if (enemy.xp) {
                ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius, enemy.radius * 2, enemy.radius * 2);
            } else {
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            if (enemy.isStunned) {
                ctx.strokeStyle = currentTheme.canvasColors.enemyStunEffect;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius + 4, 0, Math.PI * 2);
                ctx.stroke();
            }
        } else {
            const grad = ctx.createRadialGradient(enemy.x, enemy.y, 0, enemy.x, enemy.y, 4);
            grad.addColorStop(0, '#ffcc00');
            grad.addColorStop(1, '#ff6600');
            ctx.fillStyle = grad;
            if (enemy.xp) {
                ctx.fillRect(enemy.x - 4, enemy.y - 4, 8, 8);
            } else {
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        const healthPercent = Math.max(0, enemy.health / enemy.maxHealth);
        const barWidth = sensorUpgrades.enemyVisuals ? enemy.radius * 2 : 8;
        const barHeight = 4;
        const barX = enemy.x - barWidth / 2;
        const barYOffset = sensorDisplayMode === 'off' ? 15 : 10;
        const barY = enemy.y - (sensorUpgrades.enemyVisuals ? enemy.radius : 4) - barYOffset;

        if (sensorDisplayMode === 'inline') {
            const infoLines = [];
            if (!sensorUpgrades.enemyVisuals) {
                infoLines.push('Hannah Undefined');
                infoLines.push('Upgrade the Sensor Array');
            } else {
                infoLines.push(enemy.type);
                infoLines.push(`Speed: ${enemy.speed.toFixed(1)}`);
                infoLines.push(`Size: ${enemy.radius}`);
                if (sensorUpgrades.showHealthBars) {
                    infoLines.push(`HP: ${Math.round(enemy.health)}/${Math.round(enemy.maxHealth)}`);
                } else {
                    infoLines.push("Upgrade Sensors to Calculate Enemies' Health");
                }
            }

            const fontSize = 9;
            ctx.font = `${fontSize}px monospace`;
            const padding = 3;
            let maxW = 0;
            infoLines.forEach(t => { maxW = Math.max(maxW, ctx.measureText(t).width); });
            const boxWidth = Math.max(maxW + padding * 2, 40);
            let boxHeight = infoLines.length * (fontSize + 2) + padding * 2;
            if (sensorUpgrades.showHealthBars) boxHeight += barHeight + fontSize + 8;
            const boxX = enemy.x + bracketSize + 10;
            const boxY = enemy.y - boxHeight / 2;
            ctx.fillStyle = 'rgba(255,204,0,0.35)';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeStyle = '#ffcc00';
            ctx.beginPath();
            ctx.moveTo(enemy.x + bracketSize, enemy.y);
            ctx.lineTo(boxX, boxY + 10);
            ctx.stroke();
            let textY;
            if (sensorUpgrades.showHealthBars) {
                ctx.fillStyle = '#664400';
                ctx.fillRect(boxX + padding, boxY + padding, boxWidth - padding * 2, barHeight);
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(boxX + padding, boxY + padding, (boxWidth - padding * 2) * healthPercent, barHeight);
                ctx.fillStyle = '#000';
                ctx.font = '8px monospace';
                ctx.fillText('HP', boxX + padding, boxY + padding + barHeight + fontSize - 1);
                textY = boxY + padding + barHeight + fontSize + 4;
            } else {
                textY = boxY + padding + fontSize;
            }
            ctx.fillStyle = '#000';
            infoLines.forEach(t => { ctx.fillText(t, boxX + padding, textY); textY += fontSize + 2; });
        } else {
            if (sensorUpgrades.showHealthBars) {
                ctx.fillStyle = '#664400';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
            }
            if (sensorDisplayMode === 'hud') {
                if (!hudInfo[enemy.type]) {
                    hudInfo[enemy.type] = { speed: enemy.speed.toFixed(1), size: enemy.radius, health: Math.round(enemy.health), max: Math.round(enemy.maxHealth) };
                }
            }
        }

        if (sensorUpgrades.targetAI) {
            const shots = Math.max(0, Math.ceil((enemy.health - (enemy.allocatedDamage||0)) / base.bulletDamage));
            ctx.fillStyle = '#ffffff';
            ctx.font = '10px monospace';
            ctx.textAlign = 'center';
            const barY = enemy.y - (sensorUpgrades.enemyVisuals ? enemy.radius : 4) - 10;
            ctx.fillText(shots, enemy.x, barY - 6);
        }
    });
    updateEnemyHUD(hudInfo);


    // --- Draw Bullets ---
    bulletPool.getActiveObjects().forEach(bullet => {
        ctx.fillStyle = bullet.color || currentTheme.canvasColors.bullet;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
        ctx.fill();
    });

    // --- Draw Missiles ---
    missilePool.getActiveObjects().forEach(missile => {
        // Trail
        ctx.strokeStyle = currentTheme.canvasColors.missileTrail;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(missile.trail[0].x, missile.trail[0].y);
        for(let i = 1; i < missile.trail.length; i++) {
             ctx.globalAlpha = 1 - (i / missile.trail.length) * 0.7;
             ctx.lineTo(missile.trail[i].x, missile.trail[i].y);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Missile body
        ctx.fillStyle = missile.isMacross ? currentTheme.canvasColors.macrossMissile : currentTheme.canvasColors.missile;
        ctx.beginPath();
        // Draw a small triangle for directionality
        ctx.save();
        ctx.translate(missile.x, missile.y);
        ctx.rotate(Math.atan2(missile.dy, missile.dx));
        ctx.moveTo(3, 0);
        ctx.lineTo(-2, -2);
        ctx.lineTo(-2, 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        if (showMissileRadius) {
            ctx.strokeStyle = 'rgba(0,255,0,0.3)';
            ctx.beginPath();
            ctx.arc(missile.x, missile.y, missile.homingRadius || base.missileHomingRadius, 0, Math.PI * 2);
            ctx.stroke();
        }
    });

    // --- Draw Laser ---
    if (base.laserDamage > 0 && Date.now() < gameState.laserEffectEndTime) {
        ctx.strokeStyle = currentTheme.canvasColors.laser;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(base.x, base.y);
        ctx.lineTo(base.laserTargetX, base.laserTargetY);
        ctx.stroke();
        // Core glow
        ctx.strokeStyle = currentTheme.canvasColors.laserGlow;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(base.x, base.y);
        ctx.lineTo(base.laserTargetX, base.laserTargetY);
        ctx.stroke();
    }

    // --- Draw Particles ---
    drawParticles();

    const visibleRadius = Math.max(
        base.cannonRange,
        base.missileTargetingRadius,
        base.laserRange,
        base.sensorRange,
        base.stunRadius
    );
    applyOverlay(visibleRadius);
}

// --- Canvas Ring UI Drawing Helper ---
function drawRingUIElement(type, radius, labelText, categoryIndex, upgradeIndex, angle, color) {
    const upgradeDef = upgradeTree[categoryIndex].upgrades[upgradeIndex];
    const currentLevel = upgradeDef.level;
    const maxLevel = upgradeDef.maxLevel;
    const cost = upgradeDef.cost;
    const isMissileSubUpgrade = categoryIndex === UPGRADE_CATEGORY_MISSILE && upgradeIndex > UPGRADE_MISSILE_COUNT;
    const missilePrereqMet = !isMissileSubUpgrade || upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_COUNT].level > 0;
    const canUpgrade = gameState.credits >= cost && currentLevel < maxLevel && missilePrereqMet;


    ctx.save();
    ctx.translate(base.x, base.y);
    ctx.rotate(angle); // Rotate context to the desired angle

    const elementBaseX = radius; // Position along the rotated x-axis
    const elementBaseY = 0;
    const fontSize = parseInt(currentTheme.cssVariables['--ring-ui-font-size']) || 11;
    const padding = 3;
    const boxSize = 8;
    const boxSpacing = 2;
    const totalBoxesWidth = maxLevel * boxSize + (maxLevel - 1) * boxSpacing;

    // Use theme font if specified, otherwise default
    ctx.font = `${fontSize}px ${currentTheme.cssVariables['--font-family'] || "'Press Start 2P', monospace"}`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Calculate total width needed
    const labelWidth = ctx.measureText(labelText).width;
    const costText = `$${cost}`;
    const costWidth = ctx.measureText(costText).width;
    const totalWidth = labelWidth + padding * 2 + totalBoxesWidth + padding * 2 + (canUpgrade ? costWidth + padding : 0);
    const totalHeight = fontSize + padding * 2;

    // Center the element horizontally
    const startX = elementBaseX - totalWidth / 2;

    // Background (optional, subtle)
    // ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
    // ctx.fillRect(startX - padding, elementBaseY - totalHeight / 2 - padding, totalWidth + padding*2, totalHeight + padding*2);

    let currentX = startX;

    // Draw Label Text
    ctx.fillStyle = color;
    ctx.fillText(labelText, currentX + labelWidth / 2, elementBaseY);
    currentX += labelWidth + padding * 2;

    // Draw Upgrade Boxes
    const boxStartY = elementBaseY - boxSize / 2;
    for (let i = 0; i < maxLevel; i++) {
        const boxX = currentX + i * (boxSize + boxSpacing);
        if (i < currentLevel) {
            ctx.fillStyle = color; // Use the passed-in ring color for filled boxes
            ctx.fillRect(boxX, boxStartY, boxSize, boxSize);
        } else if (i === currentLevel && canUpgrade) {
            // Pulsing effect for next available upgrade
            const pulse = Math.abs(Math.sin(Date.now() / 300));
            // Calculate inverted color based on the ring's base color
            const baseColorMatch = color.match(/(\d+(\.\d+)?)/g);
            let invertedColor = 'rgba(255, 255, 255, 0.7)'; // Default to white if parsing fails

            if (baseColorMatch && baseColorMatch.length >= 3) {
                 const r = parseInt(baseColorMatch[0]);
                 const g = parseInt(baseColorMatch[1]);
                 const b = parseInt(baseColorMatch[2]);
                 invertedColor = `rgba(${255 - r}, ${255 - g}, ${255 - b}, ${0.5 + pulse * 0.5})`; // Invert RGB, apply pulsing alpha
            } else {
                 // Attempt to handle hex colors if needed (simplified)
                 if (color.startsWith('#') && color.length === 7) {
                     const r = parseInt(color.substring(1, 3), 16);
                     const g = parseInt(color.substring(3, 5), 16);
                     const b = parseInt(color.substring(5, 7), 16);
                     invertedColor = `rgba(${255 - r}, ${255 - g}, ${255 - b}, ${0.5 + pulse * 0.5})`;
                 }
            }

            ctx.fillStyle = invertedColor;
            ctx.fillRect(boxX, boxStartY, boxSize, boxSize);
        } else {
             // Empty box background using theme color
            ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50, 50, 50, 0.7)';
            ctx.fillRect(boxX, boxStartY, boxSize, boxSize);
        }
        // Border (using the main ring color)
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.strokeRect(boxX, boxStartY, boxSize, boxSize);
    }
    const boxesEndX = currentX + totalBoxesWidth;
    currentX += totalBoxesWidth + padding * 2;

    // Draw Cost Text (if upgradable)
    if (canUpgrade && currentLevel < maxLevel) {
        ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230, 181, 75, 1)'; // Use theme color or default green
        ctx.fillText(costText, currentX + costWidth / 2, elementBaseY);
        currentX += costWidth + padding;
    } else if (currentLevel >= maxLevel) {
        const maxText = "MAX";
        const maxTextWidth = ctx.measureText(maxText).width;
        ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxMax || color; // Use theme color or ring color
        ctx.fillText(maxText, currentX + maxTextWidth / 2, elementBaseY);
        currentX += maxTextWidth + padding;
    }

    // Store clickable region - use non-rotated coordinates
    // Calculate the bounding box in the unrotated coordinate system
    const regionWidth = totalWidth + padding * 2;
    const regionHeight = totalHeight + padding * 2;
    const regionCenterX = base.x + Math.cos(angle) * radius;
    const regionCenterY = base.y + Math.sin(angle) * radius;

    // Simple AABB (Axis-Aligned Bounding Box) for clicking, might need rotation if precise clicks are needed
    // For simplicity, using a larger circular region around the center point
    const clickRadius = regionWidth / 1.5; // Make click area reasonably large

    ringClickRegions.push({
        type: type,
        x: regionCenterX,
        y: regionCenterY,
        radius: clickRadius, // Using radius for simple check
        categoryIndex: categoryIndex,
        upgradeIndex: upgradeIndex
    });


    ctx.restore();
}

// --- Canvas Collapsible Upgrade Category UI Drawing Helper ---
// Modified to handle a whole category of upgrades

function drawCollapsibleUpgradeElement(x, y, title, category, categoryIndex, isExpanded, color, hasAvailable) {
    const fontSize = parseInt(currentTheme.cssVariables['--upgrade-button-font-size']) || 12;
    const padding = 8;
    const headerHeight = fontSize + padding * 2;
    const boxWidth = 170;

    ctx.font = `${fontSize}px ${currentTheme.cssVariables['--font-family'] || "'Press Start 2P', monospace"}`;
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';

    // Header box
    ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
    ctx.fillRect(x, y, boxWidth, headerHeight);
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, boxWidth, headerHeight);

    if (hasAvailable) {
        ctx.fillStyle = 'rgba(0,255,0,0.3)';
        ctx.fillRect(x, y, boxWidth, headerHeight);
    }

    ctx.fillStyle = hasAvailable ? '#00ff00' : color;
    ctx.fillText(title, x + padding, y + padding);
    ctx.textAlign = 'right';
    ctx.fillText(isExpanded ? '-' : '+', x + boxWidth - padding, y + padding);
    ctx.textAlign = 'left';

    if (isExpanded) {
        const connectX = x + boxWidth + 10;
        const panelX = connectX + 10;

        const buttons = [];
        let focusButton = null;
        let targetButton = null;
        let manualButton = null;
        let maxTextWidth = 0;
        category.upgrades.forEach((u, idx) => {
            if (categoryIndex === UPGRADE_CATEGORY_CANNON && idx === UPGRADE_CANNON_FOCUS_RADIUS) {
                const lines = [u.name];
                if (u.level < u.maxLevel) {
                    lines.push(`Cost: $${u.cost}`);
                } else {
                    lines.push('MAX');
                }
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                const barWidth = u.maxLevel * 10 + (u.maxLevel - 1) * 2;
                maxTextWidth = Math.max(maxTextWidth, textWidth, barWidth);
                const buttonHeight = lines.length * fontSize + padding * 3 + 10;
                focusButton = {u, lines, height: buttonHeight, progressBar: true, idx};
            } else if (categoryIndex === UPGRADE_CATEGORY_SENSORS && idx === UPGRADE_SENSOR_TARGET_AI) {
                const stats = u.g(u.level, u.cost, u.maxLevel);
                const lines = `${u.name}: ${stats}`.split('\n');
                if (u.level < u.maxLevel) {
                    lines.push(`Cost: $${u.cost}`);
                } else {
                    lines.push('MAX');
                }
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                maxTextWidth = Math.max(maxTextWidth, textWidth);
                const buttonHeight = lines.length * fontSize + padding * 2;
                targetButton = {u, lines, height: buttonHeight, idx};
            } else if (categoryIndex === UPGRADE_CATEGORY_LASER && idx === UPGRADE_LASER_MANUAL) {
                const stats = u.g(u.level, u.cost, u.maxLevel);
                const lines = `${u.name}: ${stats}`.split('\n');
                if (u.level < u.maxLevel) {
                    lines.push(`Cost: $${u.cost}`);
                } else {
                    lines.push('MAX');
                }
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                maxTextWidth = Math.max(maxTextWidth, textWidth);
                const buttonHeight = lines.length * fontSize + padding * 2;
                manualButton = {u, lines, height: buttonHeight, idx};
            } else if (u.progressBar) {
                const lines = [u.name];
                if (u.level < u.maxLevel) {
                    lines.push(`Cost: $${u.cost}`);
                } else {
                    lines.push('MAX');
                }
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                const barWidth = u.maxLevel * 10 + (u.maxLevel - 1) * 2; // progress boxes
                maxTextWidth = Math.max(maxTextWidth, textWidth, barWidth);
                const buttonHeight = lines.length * fontSize + padding * 3 + 10; // extra space for bar
                buttons.push({u, lines, height: buttonHeight, progressBar: true, idx});
            } else {
                const stats = u.g(u.level, u.cost, u.maxLevel);
                const lines = `${u.name}: ${stats}`.split('\n');
                if (u.level < u.maxLevel) {
                    lines.push(`Cost: $${u.cost}`);
                } else {
                    lines.push('MAX');
                }
                const textWidth = Math.max(...lines.map(line => ctx.measureText(line).width));
                maxTextWidth = Math.max(maxTextWidth, textWidth);
                const buttonHeight = lines.length * fontSize + padding * 2;
                buttons.push({u, lines, height: buttonHeight, idx});
            }
        });

        const buttonWidth = Math.max(150, maxTextWidth + padding * 2);
        let currentY = y;
        const centers = [];
        let gunButtonY = null;
        let calcHealthButtonY = null;
        let laserButtonY = null;

        // Compute center positions
        let tempY = y;
        buttons.forEach(b => {
            const center = tempY + b.height / 2;
            centers.push(center);
            if (categoryIndex === UPGRADE_CATEGORY_CANNON && b.idx === UPGRADE_CANNON_MULTIBARREL) {
                gunButtonY = tempY;
            }
            if (categoryIndex === UPGRADE_CATEGORY_SENSORS && b.idx === UPGRADE_SENSOR_HEALTHBARS) {
                calcHealthButtonY = tempY;
            }
            if (categoryIndex === UPGRADE_CATEGORY_LASER && b.idx === UPGRADE_LASER_DAMAGE) {
                laserButtonY = tempY;
            }
            tempY += b.height + 10;
        });

        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + boxWidth, y + headerHeight / 2);
        ctx.lineTo(connectX, y + headerHeight / 2);
        ctx.lineTo(connectX, centers[centers.length - 1]);
        ctx.stroke();
        centers.forEach(c => {
            ctx.beginPath();
            ctx.moveTo(connectX, c);
            ctx.lineTo(panelX, c);
            ctx.stroke();
        });

        currentY = y;
        buttons.forEach((b, idx) => {
            const btnY = currentY;
            ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
            ctx.fillRect(panelX, btnY, buttonWidth, b.height);
            ctx.strokeStyle = color;
            ctx.strokeRect(panelX, btnY, buttonWidth, b.height);

            let canAfford = gameState.credits >= b.u.cost && b.u.level < b.u.maxLevel;
            if (categoryIndex === UPGRADE_CATEGORY_MISSILE && idx > UPGRADE_MISSILE_COUNT &&
                upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_COUNT].level === 0) {
                canAfford = false;
            }
            if (categoryIndex === UPGRADE_CATEGORY_CANNON && idx === UPGRADE_CANNON_FOCUS_RADIUS &&
                upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_MULTIBARREL].level === 0) {
                canAfford = false;
            }

            if (canAfford) {
                ctx.fillStyle = 'rgba(0,255,0,0.2)';
                ctx.fillRect(panelX, btnY, buttonWidth, b.height);
            }

            ctx.fillStyle = canAfford ? '#00ff00' : (currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230,181,75,1)');
            let textY = btnY + padding;
            b.lines.forEach(line => {
                ctx.fillText(line, panelX + padding, textY);
                textY += fontSize;
            });

            if (b.progressBar) {
                const boxSize = 10;
                const boxSpacing = 2;
                const startX = panelX + padding;
                const barY = textY + padding / 2;
                for (let i = 0; i < b.u.maxLevel; i++) {
                    const boxX = startX + i * (boxSize + boxSpacing);
                    const value = (i + 1) * 10;
                    if (i < b.u.level) {
                        ctx.fillStyle = '#ffff00';
                    } else {
                        ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
                    }
                    ctx.fillRect(boxX, barY, boxSize, boxSize);
                    ctx.strokeStyle = (base.focusRadiusSetting * 100 === value) ? 'lime' : (canAfford ? '#00ff00' : (currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230,181,75,1)'));
                    ctx.lineWidth = (base.focusRadiusSetting * 100 === value) ? 2 : 1;
                    ctx.strokeRect(boxX, barY, boxSize, boxSize);
                    if (categoryIndex === UPGRADE_CATEGORY_CANNON && idx === UPGRADE_CANNON_FOCUS_RADIUS) {
                        ringClickRegions.push({
                            type: 'focus_notch',
                            x: boxX,
                            y: barY,
                            width: boxSize,
                            height: boxSize,
                            value: value
                        });
                    }
                }
                textY += boxSize + padding;
            }

            ringClickRegions.push({
                type: 'collapsible_upgrade_button',
                x: panelX,
                y: btnY,
                width: buttonWidth,
                height: b.height,
                categoryIndex: categoryIndex,
                upgradeIndex: b.idx
            });

            currentY += b.height + 10;
        });

        if (focusButton) {
            const subX = panelX + buttonWidth + 40;
            const btnY = gunButtonY !== null ? gunButtonY : currentY;
            ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
            ctx.fillRect(subX, btnY, buttonWidth, focusButton.height);
            ctx.strokeStyle = color;
            ctx.strokeRect(subX, btnY, buttonWidth, focusButton.height);

            let canAfford = gameState.credits >= focusButton.u.cost && focusButton.u.level < focusButton.u.maxLevel &&
                             upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_MULTIBARREL].level > 0;
            if (canAfford) {
                ctx.fillStyle = 'rgba(0,255,0,0.2)';
                ctx.fillRect(subX, btnY, buttonWidth, focusButton.height);
            }
            ctx.fillStyle = canAfford ? '#00ff00' : (currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230,181,75,1)');
            let textY = btnY + padding;
            focusButton.lines.forEach(line => {
                ctx.fillText(line, subX + padding, textY);
                textY += fontSize;
            });

            // progressBar drawing for focusButton
            const boxSize = 10;
            const boxSpacing = 2;
            const startX = subX + padding;
            const barY = textY + padding / 2;
            for (let i = 0; i < focusButton.u.maxLevel; i++) {
                const boxX = startX + i * (boxSize + boxSpacing);
                const value = (i + 1) * 10;
                if (i < focusButton.u.level) {
                    ctx.fillStyle = '#ffff00';
                } else {
                    ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
                }
                ctx.fillRect(boxX, barY, boxSize, boxSize);
                ctx.strokeStyle = (base.focusRadiusSetting * 100 === value) ? 'lime' : (canAfford ? '#00ff00' : (currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230,181,75,1)'));
                ctx.lineWidth = (base.focusRadiusSetting * 100 === value) ? 2 : 1;
                ctx.strokeRect(boxX, barY, boxSize, boxSize);
                ringClickRegions.push({
                    type: 'focus_notch',
                    x: boxX,
                    y: barY,
                    width: boxSize,
                    height: boxSize,
                    value: value
                });
            }
            textY += boxSize + padding;

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelX + buttonWidth, btnY + focusButton.height / 2);
            ctx.lineTo(subX, btnY + focusButton.height / 2);
            ctx.stroke();

            ringClickRegions.push({
                type: 'collapsible_upgrade_button',
                x: subX,
                y: btnY,
                width: buttonWidth,
                height: focusButton.height,
                categoryIndex: categoryIndex,
                upgradeIndex: focusButton.idx
            });
        }

        if (targetButton) {
            const subX = panelX + buttonWidth + 40;
            const btnY = calcHealthButtonY !== null ? calcHealthButtonY : currentY;
            ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
            ctx.fillRect(subX, btnY, buttonWidth, targetButton.height);
            ctx.strokeStyle = color;
            ctx.strokeRect(subX, btnY, buttonWidth, targetButton.height);

            let canAfford = gameState.credits >= targetButton.u.cost && targetButton.u.level < targetButton.u.maxLevel &&
                             upgradeTree[UPGRADE_CATEGORY_SENSORS].upgrades[UPGRADE_SENSOR_HEALTHBARS].level > 0;
            if (canAfford) {
                ctx.fillStyle = 'rgba(0,255,0,0.2)';
                ctx.fillRect(subX, btnY, buttonWidth, targetButton.height);
            }
            ctx.fillStyle = canAfford ? '#00ff00' : (currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230,181,75,1)');
            let textY = btnY + padding;
            targetButton.lines.forEach(line => {
                ctx.fillText(line, subX + padding, textY);
                textY += fontSize;
            });

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelX + buttonWidth, btnY + targetButton.height / 2);
            ctx.lineTo(subX, btnY + targetButton.height / 2);
            ctx.stroke();

            ringClickRegions.push({
                type: 'collapsible_upgrade_button',
                x: subX,
                y: btnY,
                width: buttonWidth,
                height: targetButton.height,
                categoryIndex: categoryIndex,
                upgradeIndex: targetButton.idx
            });
        }

        if (manualButton) {
            const subX = panelX + buttonWidth + 40;
            const btnY = laserButtonY !== null ? laserButtonY : currentY;
            ctx.fillStyle = currentTheme.canvasColors.ringUpgradeBoxBg || 'rgba(50,50,50,0.7)';
            ctx.fillRect(subX, btnY, buttonWidth, manualButton.height);
            ctx.strokeStyle = color;
            ctx.strokeRect(subX, btnY, buttonWidth, manualButton.height);

            let canAfford = gameState.credits >= manualButton.u.cost && manualButton.u.level < manualButton.u.maxLevel &&
                             upgradeTree[UPGRADE_CATEGORY_LASER].upgrades[UPGRADE_LASER_DAMAGE].level > 0;
            if (canAfford) {
                ctx.fillStyle = 'rgba(0,255,0,0.2)';
                ctx.fillRect(subX, btnY, buttonWidth, manualButton.height);
            }
            ctx.fillStyle = canAfford ? '#00ff00' : (currentTheme.canvasColors.ringUpgradeBoxText || 'rgba(230,181,75,1)');
            let textY = btnY + padding;
            manualButton.lines.forEach(line => {
                ctx.fillText(line, subX + padding, textY);
                textY += fontSize;
            });

            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(panelX + buttonWidth, btnY + manualButton.height / 2);
            ctx.lineTo(subX, btnY + manualButton.height / 2);
            ctx.stroke();

            ringClickRegions.push({
                type: 'collapsible_upgrade_button',
                x: subX,
                y: btnY,
                width: buttonWidth,
                height: manualButton.height,
                categoryIndex: categoryIndex,
                upgradeIndex: manualButton.idx
            });
        }
    }

    ringClickRegions.push({
        type: 'collapsible_upgrade_header',
        x: x,
        y: y,
        width: boxWidth,
        height: headerHeight,
        categoryIndex: categoryIndex,
        upgradeIndex: -1
    });

    return headerHeight;
}

// --- Upgrade Logic ---
function purchaseUpgrade(categoryIndex, upgradeIndex) {
    const upgrade = upgradeTree[categoryIndex].upgrades[upgradeIndex];

    if (categoryIndex === UPGRADE_CATEGORY_DEBUG) {
        gameState.credits += 100000;
        updateHUD();
        showToast('Cheated 100,000 credits!');
        return;
    }

    // Check prerequisite for missile sub-upgrades
    if (categoryIndex === UPGRADE_CATEGORY_MISSILE && upgradeIndex > UPGRADE_MISSILE_COUNT) {
        if (upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_COUNT].level === 0) {
            showToast("Requires Missile System Acquisition first!", 2500);
            return; // Cannot buy sub-upgrades if missiles not acquired
        }
    }
    if (categoryIndex === UPGRADE_CATEGORY_CANNON && upgradeIndex === UPGRADE_CANNON_FOCUS_RADIUS) {
        if (upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_MULTIBARREL].level === 0) {
            showToast("Requires Guns upgrade first!", 2500);
            return;
        }
    }
    if (categoryIndex === UPGRADE_CATEGORY_SENSORS && upgradeIndex === UPGRADE_SENSOR_TARGET_AI) {
        if (upgradeTree[UPGRADE_CATEGORY_SENSORS].upgrades[UPGRADE_SENSOR_HEALTHBARS].level === 0) {
            showToast("Requires Calculate Enemies' Health first!", 2500);
            return;
        }
    }
    if (categoryIndex === UPGRADE_CATEGORY_LASER && upgradeIndex === UPGRADE_LASER_MANUAL) {
        if (upgradeTree[UPGRADE_CATEGORY_LASER].upgrades[UPGRADE_LASER_DAMAGE].level === 0) {
            showToast("Requires Laser upgrade first!", 2500);
            return;
        }
    }

    if (gameState.credits >= upgrade.cost && upgrade.level < upgrade.maxLevel) {
        gameState.credits -= upgrade.cost;
        upgrade.level++;
        upgrade.cost = Math.ceil(upgrade.cost * 1.5); // Increase cost

        applyUpgradeEffect(categoryIndex, upgradeIndex, true); // Apply effect of new level

        updateHUD();
        drawGame();
        showToast(`Upgraded ${upgrade.name}!`);
        saveGame(); // Auto-save on upgrade
    } else if (gameState.credits < upgrade.cost) {
         showToast("Not enough credits!", 1500);
    } else if (upgrade.level >= upgrade.maxLevel) {
         showToast(`${upgrade.name} at Max Level!`, 1500);
    }
}

function applyUpgradeEffect(categoryIndex, upgradeIndex, isNewPurchase) {
    const upgrade = upgradeTree[categoryIndex].upgrades[upgradeIndex];
    const level = upgrade.level; // Current level after potential purchase

    switch(categoryIndex) {
        case UPGRADE_CATEGORY_CANNON:
            switch(upgradeIndex) {
                case UPGRADE_CANNON_FIRERATE: base.fireRate = upgrade.f(level); break;
                case UPGRADE_CANNON_DAMAGE: base.bulletDamage = upgrade.f(level); break;
                case UPGRADE_CANNON_RANGE:
                    base.cannonRange = upgrade.f(level);
                    // Update sensor range if Electronic FOV purchased
                    const sensorUpgrade = upgradeTree[UPGRADE_CATEGORY_SENSORS].upgrades[UPGRADE_SENSOR_RANGE];
                    base.sensorRange = base.cannonRange * sensorUpgrade.f(sensorUpgrade.level);
                    // Also update missile targeting radius if missiles are active
                    if (upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_COUNT].level > 0) {
                         const missileRangeUpgrade = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_RANGE];
                         base.missileTargetingRadius = missileRangeUpgrade.f(missileRangeUpgrade.level);
                    }
                    break;
                case UPGRADE_CANNON_MULTIBARREL: base.gunBarrelCount = upgrade.f(level); break;
                case UPGRADE_CANNON_FOCUS_RADIUS:
                    base.focusRadiusSetting = upgrade.f(level);
                    break;
            }
            break;
        case UPGRADE_CATEGORY_DEFENSE:
            switch(upgradeIndex) {
                case UPGRADE_DEFENSE_HEALTH:
                    const oldMaxHealth = gameState.maxHealth;
                    gameState.maxHealth = upgrade.f(level);
                    // Heal amount equal to the increase
                    gameState.currentHealth += (gameState.maxHealth - oldMaxHealth);
                    gameState.currentHealth = Math.min(gameState.maxHealth, gameState.currentHealth); // Cap at new max
                    updateHUD();
                    break;
                case UPGRADE_DEFENSE_MOVEMENT: base.currentMoveSpeed = upgrade.f(level); break;
            }
            break;
        case UPGRADE_CATEGORY_LASER:
             if (upgradeIndex === UPGRADE_LASER_DAMAGE) {
                 base.laserDamage = upgrade.f(level);
                 if (level === 1 && isNewPurchase) { // First level purchased
                     base.laserRange = Math.min(canvasWidth, canvasHeight) * 0.3; // Set initial range
                 } else if (level > 0) {
                     // Optionally increase range slightly with levels?
                     base.laserRange = Math.min(canvasWidth, canvasHeight) * (0.3 + (level - 1) * 0.02);
                 } else {
                     base.laserRange = 0; // Turn off if somehow level becomes 0
                 }
             } else if (upgradeIndex === UPGRADE_LASER_MANUAL) {
                 base.manualTargeting = level > 0;
             }
             break;
        case UPGRADE_CATEGORY_MISSILE:
            switch(upgradeIndex) {
                case UPGRADE_MISSILE_COUNT:
                    base.missileCount = upgrade.f(level);
                    if (level === 1 && isNewPurchase) {
                        // First missile acquisition - grant base level of sub-upgrades?
                        // Or just enable them for purchase? Let's just enable.
                         const missileRangeUpgrade = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_RANGE];
                         base.missileTargetingRadius = missileRangeUpgrade.f(missileRangeUpgrade.level); // Apply current level (might be 0)

                         const missileDmgUpgrade = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_DAMAGE];
                         base.missileDamage = missileDmgUpgrade.f(missileDmgUpgrade.level);

                        const missileHomingUpgrade = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_HOMING];
                         base.missileHomingRadius = missileHomingUpgrade.f(missileHomingUpgrade.level);
                         base.missileTurnSpeed = 0.05 + missileHomingUpgrade.level * 0.01;
                         base.missileSpeedMultiplier = 1 + missileHomingUpgrade.level * 0.05;
                    }
                    break;
                case UPGRADE_MISSILE_RANGE: base.missileTargetingRadius = upgrade.f(level); break;
                case UPGRADE_MISSILE_DAMAGE: base.missileDamage = upgrade.f(level); break;
                case UPGRADE_MISSILE_HOMING:
                    base.missileHomingRadius = upgrade.f(level);
                    base.missileTurnSpeed = 0.05 + level * 0.01;
                    base.missileSpeedMultiplier = 1 + level * 0.05;
                    break;
                case UPGRADE_MISSILE_MACROSS:
                    base.macrossMissileCount = upgrade.f(level);
                    base.macrossMissileDamage = 20 + level * 5;
                    getElement('macrossButton').style.display = level > 0 ? 'block' : 'none';
                    // Enable button immediately if cooldown is 0
                    if (level > 0 && gameState.macrossCooldownTimer <= 0) {
                        getElement('macrossButton').disabled = false;
                        getElement('macrossButton').classList.add('active');
                    }
                    break;
            }
            break;
        case UPGRADE_CATEGORY_SPECIAL:
            if (upgradeIndex === UPGRADE_SPECIAL_STUN) {
                 base.stunLevel = level; // Store level, used directly in enemy update
                 if (level === 1 && isNewPurchase) { // First level
                     base.stunRadius = Math.min(canvasWidth, canvasHeight) / 3; // Set initial radius
                 } else if (level > 0) {
                     // Optionally increase radius slightly with levels?
                     base.stunRadius = Math.min(canvasWidth, canvasHeight) / 3 * (1 + (level-1)*0.03);
                 } else {
                     base.stunRadius = 0;
                 }
            }
            break;
        case UPGRADE_CATEGORY_SENSORS:
            switch(upgradeIndex) {
                case UPGRADE_SENSOR_RANGE:
                    base.sensorRange = base.cannonRange * upgrade.f(level);
                    break;
                case UPGRADE_SENSOR_OUTLINES:
                    sensorUpgrades.enemyVisuals = level > 0;
                    enemyIntel.active = level > 0;
                    if(level===1 && isNewPurchase){ enemyIntel.known = {}; enemyIntel.order = []; identifyClosestEnemyInRange(); }
                    updateEnemyStatsPanel();
                    break;
                case UPGRADE_SENSOR_HEALTHBARS:
                    sensorUpgrades.showHealthBars = level > 0;
                    break;
                case UPGRADE_SENSOR_TARGET_AI:
                    sensorUpgrades.targetAI = level > 0;
                    break;
            }
            break;
    }
}


// --- Special Actions ---
function fireLaserAt(target) {
    target.isTargeted = true;
    target.targetLockTime = TARGET_LOCK_DURATION;
    target.health -= base.laserDamage;
    const now = Date.now();
    gameState.lastLaserFireTime = now;
    gameState.laserEffectEndTime = now + 200;
    base.laserTargetX = target.x;
    base.laserTargetY = target.y;
    for (let i = 0; i < 5; i++) {
        const t = i / 5;
        createParticle(
            base.x + (target.x - base.x) * t,
            base.y + (target.y - base.y) * t,
            currentTheme.canvasColors.laser, 1, 0.2, 3
        );
    }
    if (target.health <= 0) {
        gameState.credits += target.creditsValue;
        gameState.score += target.creditsValue * 20;
        gameState.enemiesKilled++;
        createExplosion(target.x, target.y, target.color, 40, target.radius);
        enemyPool.release(target);
        if (target.xp) {
            gameState.doubleFireRateEndTime = Date.now() + 20000;
            showToast('Fire rate doubled!', 3000);
        }
        updateHUD();
        updateUpgradeAvailabilityFlags();
    }
}

function fireMacrossMissiles() {
    if (gameState.macrossCooldownTimer <= 0 && base.macrossMissileCount > 0) {
        const count = base.macrossMissileCount;
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2 + Math.random() * 0.1 - 0.05; // Add slight random angle variation
            const launchSpeed = 3 + Math.random() * 3; // Vary launch speeds

            missilePool.get({
                x: base.x,
                y: base.y,
                dx: Math.cos(angle),
                dy: Math.sin(angle),
                t: null,
                speed: launchSpeed,
                turnSpeed: base.missileTurnSpeed,
                homingRadius: base.missileHomingRadius,
                macross: true,
                homingActive: true,
                startX: base.x,
                startY: base.y,
                rangeLimit: base.missileTargetingRadius * 1.1
            });
        }

        createExplosion(base.x, base.y, 'red', 50, 40); // Big launch effect
        showToast('Macross Missile Massacre!');

        const cooldownLevel = upgradeTree[UPGRADE_CATEGORY_MISSILE].upgrades[UPGRADE_MISSILE_MACROSS].level;
        gameState.macrossCooldownTimer = MACROSS_BASE_COOLDOWN - cooldownLevel * MACROSS_COOLDOWN_REDUCTION_PER_LEVEL;
        getElement('macrossButton').disabled = true;
        getElement('macrossButton').classList.remove('active');
    }
}

function sendNextWave() {
    if (!waveBossAlive[gameState.wave]) {
        spawnEnemy(true);
    }
    startNextWave();
}

// --- Menu Toggles ---
function toggleHotkeys() {
    getElement('hotkeys').classList.toggle('show');
}

function toggleRingInfoDisplay() {
    showRingInfo = !showRingInfo;
    getElement('toggleInfoButton').classList.toggle('active', showRingInfo);
    // No need to add/remove DOM elements anymore, drawGame handles visibility
    showToast(showRingInfo ? 'Ring info enabled' : 'Ring info disabled');
}

function cycleSensorDisplayMode() {
    if (sensorDisplayMode === 'inline') {
        sensorDisplayMode = 'hud';
    } else if (sensorDisplayMode === 'hud') {
        sensorDisplayMode = 'off';
    } else {
        sensorDisplayMode = 'inline';
    }
    const label = sensorDisplayMode.charAt(0).toUpperCase() + sensorDisplayMode.slice(1);
    getElement('sensorDisplayToggle').textContent = label;
    drawGame();
}

function toggleFullScreen() {
    const doc = document;
    if (!doc.fullscreenElement) {
        const el = doc.documentElement;
        if (el.requestFullscreen) el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        else if (el.msRequestFullscreen) el.msRequestFullscreen();
    } else {
        if (doc.exitFullscreen) doc.exitFullscreen();
        else if (doc.webkitExitFullscreen) doc.webkitExitFullscreen();
        else if (doc.msExitFullscreen) doc.msExitFullscreen();
    }
}

function handleFullscreenChange() {
    const btn = getElement('fullscreenButton');
    const inFull = !!document.fullscreenElement;
    btn.textContent = inFull ? '\u2715' : '\u26F6';
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    if (fogCanvas) {
        fogCanvas.width = canvasWidth;
        fogCanvas.height = canvasHeight;
    }
    if (base) {
        base.x = canvasWidth / 2;
        base.y = canvasHeight / 2;
        baseStartX = base.x;
        baseStartY = base.y;
    }
    drawGame();
}

function toggleMute() {
    isMuted = !isMuted;
    localStorage.setItem('ode_isMuted', isMuted);
    const btn = getElement('muteButton');
    btn.textContent = isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A';
}

function updateEnemyHUD(info) {
    const hud = getElement('enemyHUD');
    if (!hud) return;
    hud.classList.remove('show');
    if (sensorDisplayMode !== 'hud') return;
    // HUD mode no longer displays a popup since enemy stats panel replaces it
}
function updateEnemyStatsPanel(){
    const panel=getElement("enemyStatsPanel");
    const list=getElement("enemyStatsContent");
    let html="";
    enemyIntel.order.forEach(t=>{const d=enemyIntel.known[t];html+=`<div>${t}: Spd ${d.speed} HP ${d.health}</div>`;});
    if(html){
        list.innerHTML=html;
    }else if(enemyIntel.active){
        list.innerHTML="<div>Ready - awaiting first enemy scan</div>";
    }else{
        list.innerHTML="<div>Purchase Enemy Identification under Sensors upgrades</div>";
    }
    const hudBar=getElement("hud");
    const hotkeys=getElement("hotkeys");
    if(hotkeysWidth===null){
        hotkeysWidth=hotkeys.offsetWidth;
    }
    panel.style.width="";
    panel.style.maxWidth=hotkeysWidth+"px";
    let top=hudBar.offsetHeight+10;
    if(hotkeys.classList.contains("show")) top+=hotkeys.offsetHeight+10;
    panel.style.top=top+"px";
}

function toggleEnemyStatsPanel(){
    const p=getElement("enemyStatsPanel");
    const arrow=getElement("enemyStatsToggle");
    p.classList.toggle("collapsed");
    arrow.textContent=p.classList.contains("collapsed")?'▸':'▾';
}

function beep(){
    if(isMuted) return;
    try{const c=new(window.AudioContext||window.webkitAudioContext)();const o=c.createOscillator();o.type="square";o.frequency.value=800;o.connect(c.destination);o.start();setTimeout(()=>{o.stop();c.close();},100);}catch(e){}
}

function showEnemyIntelPopup(type,stats){
    const c=getElement("enemyIntelContent");
    c.innerHTML=`<div>${type}</div><div>Speed: ${stats.speed}</div><div>Health: ${stats.health}</div><div>Pattern: ${stats.attack}</div>`;
    getElement("enemyIdentificationPopup").style.display="flex";
    beep();
}
function hideEnemyIntelPopup(){
    getElement("enemyIdentificationPopup").style.display="none";
    resumeGame();
    updateEnemyStatsPanel();
}

function identifyEnemy(enemy){
    if(!enemyIntel.active||enemyIntel.known[enemy.type]) return;
    enemyIntel.known[enemy.type]={speed:enemy.speed.toFixed(1),health:Math.round(enemy.maxHealth),attack:"Unknown"};
    enemyIntel.order.push(enemy.type);
    pauseGame();
    showEnemyIntelPopup(enemy.type,enemyIntel.known[enemy.type]);
}

function identifyClosestEnemyInRange(){
    if(!enemyIntel.active) return;
    const enemies = enemyPool.getActiveObjects();
    const range = Math.max(base.cannonRange, base.missileTargetingRadius, base.laserRange, base.sensorRange, base.stunRadius);
    let closest=null,dist=Infinity;
    enemies.forEach(e=>{
        if(!enemyIntel.known[e.type]){
            const d=Math.hypot(base.x-e.x,base.y-e.y);
            if(d<=range && d<dist){closest=e;dist=d;}
        }
    });
    if(closest) identifyEnemy(closest);
}


function toggleUpgradeCategory(index) {
    upgradeTree.forEach((cat,i)=>{cat.expanded = i===index ? !cat.expanded : false;});
    drawGame();
}


window.addEventListener('keydown', e => {

    keysPressed[e.key.toLowerCase()] = true; // Use lower case for consistency

    // Close leaderboard screen with Escape
    if (e.key === 'Escape' && getElement('leaderboard-screen').style.display !== 'none') {
        getElement('leaderboard-screen').style.display = 'none';
        unlistenLeaderboard();
        getElement('startScreen').style.display = 'flex';
    }

    // Restart game from game over or leaderboard screens with "r"
    if (e.key.toLowerCase() === 'r') {
        const gameOverVisible = getElement('gameOverScreen').style.display !== 'none';
        const leaderboardVisible = getElement('leaderboard-screen').style.display !== 'none';
        if (gameOverVisible || leaderboardVisible) {
            getElement('restartButton').click();
            return; // Prevent handling below
        }
    }

    // Handle single-press actions only if game is running
    if (isGameRunning) {
        switch (e.key.toLowerCase()) {
            case 'm': if (isGameRunning) fireMacrossMissiles(); break; // Only fire if game running
            case 'h': toggleHotkeys(); break; // Toggle hotkeys anytime
            case 'f':
                if (isGameRunning) {
                    gameState.autoFire = !gameState.autoFire;
                    showToast(gameState.autoFire ? 'Auto-fire enabled' : 'Auto-fire disabled');
                }
                break;
            case 'i': toggleEnemyStatsPanel(); break;
            case 'q':
                debugUpgradesVisible = !debugUpgradesVisible;
                drawGame();
                break; // Hidden toggle for debug upgrades
            case 'o': toggleRingInfoDisplay(); break; // Toggle info anytime
        }
    }
});

window.addEventListener('keyup', e => {
    keysPressed[e.key.toLowerCase()] = false;
});

// Mouse/Touch Dragging - Shared Logic
function handleDragStart(clientX, clientY) {
    if (!isGameRunning) return false; // Only drag if game is running

    const rect = canvas.getBoundingClientRect();
    const mouseX = clientX - rect.left;
    const mouseY = clientY - rect.top;

    if (Math.hypot(mouseX - base.x, mouseY - base.y) <= base.radius) {
        isDragging = true;
        dragStartX = mouseX;
        dragStartY = mouseY;
        baseStartX = base.x;
        baseStartY = base.y;
        wasDragging = false; // Reset flag
        isReturningToCenter = false; // Stop return-to-center if dragging starts
        return true; // Indicate drag started
    }
    return false; // Click was not on base
}

function handleDragMove(clientX, clientY) {
    if (isDragging && isGameRunning) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;

        const deltaX = mouseX - dragStartX;
        const deltaY = mouseY - dragStartY;

        if (!wasDragging && Math.hypot(deltaX, deltaY) > DRAG_THRESHOLD) {
            wasDragging = true; // It's officially a drag
        }

        // Calculate new base position
        const targetX = baseStartX + deltaX;
        const targetY = baseStartY + deltaY;

        // Clamp position within bounds
        base.x = Math.max(base.radius, Math.min(canvasWidth - base.radius, targetX));
        base.y = Math.max(base.radius, Math.min(canvasHeight - base.radius, targetY));

        // Update drag start points relative to the *new* base position for smoother continuation
        // This prevents large jumps if the base hits the edge
        // dragStartX = mouseX - (base.x - baseStartX);
        // dragStartY = mouseY - (base.y - baseStartY);
        // baseStartX = base.x; // Update base start for next delta calculation
        // baseStartY = base.y;

    }
}


function handleDragEnd() {
    if (isDragging) {
        isDragging = false;
        if (wasDragging) { // Only return to center if it was an actual drag
            isReturningToCenter = true;
            centerReturnStartTime = Date.now();
        }
        // wasDragging remains true/false based on movement during drag
    }
}

// Canvas Click (handles base click for menu, ring UI clicks)
function handleCanvasClick(clientX, clientY) {
    if (!isGameRunning) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = clientX - rect.left;
    const clickY = clientY - rect.top;

    // Check if click was part of a drag ending - if so, ignore click action
    if (wasDragging) {
        wasDragging = false; // Reset flag after checking
        return;
    }

    // 1. Check click on Canvas UI elements (tabs, then upgrade buttons)
    for (const region of ringClickRegions) {
        // Check if click is within the rectangular bounds of the region
        if (clickX >= region.x && clickX <= region.x + region.width &&
            clickY >= region.y && clickY <= region.y + region.height) {

            if (region.type === 'collapsible_upgrade_header') {
                toggleUpgradeCategory(region.categoryIndex);
                return;
            } else if (region.type === 'focus_notch') {
                const unlocked = upgradeTree[UPGRADE_CATEGORY_CANNON].upgrades[UPGRADE_CANNON_FOCUS_RADIUS].level * 10;
                if (region.value <= unlocked) {
                    base.focusRadiusSetting = region.value / 100;
                    drawGame();
                    saveGame();
                }
                return; // Handle click and exit
            } else if (region.type === 'upgrade_button' || region.type === 'collapsible_upgrade_button') {
                purchaseUpgrade(region.categoryIndex, region.upgradeIndex);
                return; // Handle click and exit
            }
        }
    }

    if (base.manualTargeting && base.laserDamage > 0 && Date.now() - gameState.lastLaserFireTime >= LASER_FIRE_INTERVAL / gameSpeedMultiplier) {
        const target = enemyPool.getActiveObjects().find(e => e.xp && Math.hypot(e.x - clickX, e.y - clickY) <= e.radius);
        if (target) {
            fireLaserAt(target);
            return;
        }
    }


    // 2. Check click on Base (opens upgrade menu) - Check this last
    // Removed base click to open full-screen upgrade menu
}


// Attach Specific Event Listeners
canvas.addEventListener('mousedown', e => {
    if(e.button === 0) { // Only left click
         handleDragStart(e.clientX, e.clientY);
    }
});
window.addEventListener('mousemove', e => {
    handleDragMove(e.clientX, e.clientY);
});
window.addEventListener('mouseup', e => {
     if(e.button === 0) {
         handleDragEnd();
         // Process click action only if not dragging
         handleCanvasClick(e.clientX, e.clientY);
     }
});

// Touch Events
canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
        const touch = e.touches[0];
        if (handleDragStart(touch.clientX, touch.clientY)) {
            e.preventDefault(); // Prevent scrolling if drag started on base
        } else {
            // Treat simple taps as clicks for menu interaction
            handleCanvasClick(touch.clientX, touch.clientY);
        }
    }
}, { passive: false });

window.addEventListener('touchmove', e => {
    if (e.touches.length === 1) {
        handleDragMove(e.touches[0].clientX, e.touches[0].clientY);
        if (isDragging) {
             e.preventDefault(); // Prevent scrolling while dragging base
        }
    }
}, { passive: false });

window.addEventListener('touchend', e => {
    if (e.changedTouches.length === 1) {
        const touch = e.changedTouches[0];
        handleDragEnd();
        // Process click action only if not dragging
        handleCanvasClick(touch.clientX, touch.clientY);
    }
});


// UI Button Listeners
getElement('startButton').onclick = startGame;
getElement('restartButton').onclick = async () => {
    if (window.pendingScore && !window.pendingScore.saved) {
        try {
            await submitScore({ initials: '???', wave: window.pendingScore.wave, time: window.pendingScore.time, ranking: window.pendingScore.ranking });
        } catch (err) {
            console.error('Auto-save failed', err);
        }
        window.pendingScore.saved = true;
    }
    startGame();
};
getElement('sensorWarningButton').onclick = dismissSensorWarning;
getElement("enemyIntelContinue").onclick=hideEnemyIntelPopup;
getElement("enemyStatsHeader").onclick=toggleEnemyStatsPanel;
getElement('playPauseButton').onclick = () => {
    if (isGameRunning) pauseGame(); else resumeGame();
};
getElement('slowDownButton').onclick = () => {
    if (!isGameRunning) return;
    if (speedIndex > 0) {
        speedIndex--;
        gameSpeedMultiplier = SPEED_STEPS[speedIndex];
        updateSpeedDisplay();
    }
};
getElement('speedUpButton').onclick = () => {
    if (!isGameRunning) return;
    if (speedIndex < SPEED_STEPS.length - 1) {
        speedIndex++;
        gameSpeedMultiplier = SPEED_STEPS[speedIndex];
        updateSpeedDisplay();
    }
};
getElement('macrossButton').onclick = fireMacrossMissiles;
getElement('toggleInfoButton').onclick = toggleRingInfoDisplay;
getElement('themeButton').onclick = cycleTheme; // Added Theme Button Listener
getElement('loadButton').onclick = loadAndStartGame; // Added Load Button Listener
getElement('clearSaveButton').onclick = clearSavedGame;
getElement('startFromHighScore').onclick = startGame;
getElement('initialsInput').addEventListener('keydown', e => {
    if (e.key === 'Enter') submitInitials();
});
getElement('initialsInput').addEventListener('input', e => {
    e.target.value = e.target.value.toUpperCase().replace(/[^A-Z0-9]/g, '');
    if (e.target.value.length >= 3) submitInitials();
});
getElement('sensorDisplayToggle').onclick = cycleSensorDisplayMode;
getElement('fullscreenButton').onclick = toggleFullScreen;
getElement('muteButton').onclick = toggleMute;
getElement('sendWaveButton').onclick = sendNextWave;

document.addEventListener('fullscreenchange', handleFullscreenChange);

// Window Resize
window.addEventListener('resize', () => {
    canvasWidth = window.innerWidth;
    canvasHeight = window.innerHeight;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;
    // No need to reposition DOM elements anymore
    // Re-applying certain base stats that depend on screen size might be needed
    // e.g., if stun radius or laser range were calculated differently based on resize.
    // For now, assume fixed calculation or recalculation within applyUpgradeEffect.
    if (isGameRunning) {
        drawGame(); // Redraw immediately after resize
    }
});


// --- Theme Switching Logic ---
function applyTheme(themeIndex) {
    currentThemeIndex = themeIndex % THEMES.length; // Cycle through themes
    currentTheme = THEMES[currentThemeIndex];

    // Apply CSS Variables
    const root = document.documentElement;
    for (const [key, value] of Object.entries(currentTheme.cssVariables)) {
        root.style.setProperty(key, value);
    }

    // Update button text (optional, if theme name changes)
    const themeButton = getElement('themeButton');
    if (themeButton) {
        themeButton.textContent = `Theme: ${currentTheme.name}`;
    }

    // Potentially update other non-CSS visual elements if needed
    // e.g., if particle generation logic changes drastically per theme



    // Force redraw of canvas with new colors
    if (isGameRunning || getElement('startScreen').style.display === 'flex' || getElement('gameOverScreen').style.display === 'flex') {
        drawGame();
    }
    showToast(`Theme set to: ${currentTheme.name}`, 1500);
}

function cycleTheme() {
    applyTheme(currentThemeIndex + 1);
    // Save the selected theme index to localStorage
    localStorage.setItem('orbitalDefenseTheme_v2.9', currentThemeIndex);
}

// --- Load and Start Game Function ---
function loadAndStartGame() {
    initializeGame(false); // Initialize basic structures without trying to load save again

    if (!loadGame()) { // Attempt to load the saved game
        showToast("Failed to load saved game.", 2000);
        // Fallback to starting a new game if loading fails catastrophically
        initializeGame(false); // Re-initialize fresh
    }

    // Common starting logic after initialization/loading
    getElement('startScreen').style.display = 'none';
    getElement('gameOverScreen').style.display = 'none';
    getElement('deathOverlay').style.display = 'none';
    pauseGame();
    gameSpeedMultiplier = 1;
    speedIndex = SPEED_STEPS.indexOf(1);
    updateSpeedDisplay();
    getElement('playPauseButton').textContent = '\u25B6';
    drawGame();
    updateHUD();
    showSensorWarning();
}


// Initial setup on load
  window.onload = () => {
    // Preload pixel font if needed (optional, adds dependency)
    // const fontLink = document.createElement('link');
    // fontLink.href = 'https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap';
    // fontLink.rel = 'stylesheet';
    // document.head.appendChild(fontLink);

      initializeGame(false); // Initialize without loading saved game yet

    // Load saved theme preference, default to "Orbital Elite" (index 0)
    const savedTheme = localStorage.getItem('orbitalDefenseTheme_v2.9');
    const savedThemeIndex = savedTheme !== null ? parseInt(savedTheme, 10) : 0;
    applyTheme(savedThemeIndex); // Apply saved or default theme

    // Set mute button state
  const muteBtn = getElement('muteButton');
  if (muteBtn) {
    muteBtn.textContent = isMuted ? '\uD83D\uDD07' : '\uD83D\uDD0A';
  }

  overlayButton = getElement('overlayButton');
  cssOverlay = getElement('cssOverlay');
  if (overlayButton) {
    overlayButton.addEventListener('click', cycleOverlay);
    overlayButton.textContent = 'Overlay: ' + OVERLAY_METHODS[overlayMode];
  }
  if (cssOverlay) cssOverlay.style.display = 'none';



    updateSpeedDisplay();

    getElement('startScreen').style.display = 'flex';
    getElement('gameOverScreen').style.display = 'none';
    // Draw initial empty state? Or just wait for game start.
    ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      // Try loading save data now, before Start Game is pressed
    tryLoadGame(); // Button visibility handled within
};

// --- Global Access (for HTML onclick) ---
window.purchaseUpgrade = purchaseUpgrade; // Make purchase function global for button clicks
window.toggleUpgradeCategory = toggleUpgradeCategory; // Expose category toggling
})(); // End IIFE
</script>
<div id="overlayContainer"></div>
<div id="cssOverlay"></div>
<div id="deathOverlay" class="overlay-desaturate" style="display:none"></div>
<div id="crt-overlay"></div>
</body>
</html>
